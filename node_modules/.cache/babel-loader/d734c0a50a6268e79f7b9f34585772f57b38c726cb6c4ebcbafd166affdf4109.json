{"ast":null,"code":"// VidSrc API service for streaming integration\n// No API key required - uses TMDB IDs directly\n\n// Simplified domain configuration - vidsrc.net as primary source\nconst VIDSRC_DOMAINS = {\n  primary: 'https://vidsrc.net/embed',\n  fallbacks: ['https://vidsrc.to/embed', 'https://vidsrc.cc/embed']\n};\n\n// Quality options for streaming\nconst QualityOptions = {\n  AUTO: 'auto',\n  Q4K: '4k',\n  Q1080P: '1080p',\n  Q720P: '720p',\n  Q480P: '480p',\n  Q360P: '360p'\n};\n\n// Error types for better error handling\nconst StreamErrorTypes = {\n  NETWORK_ERROR: 'NETWORK_ERROR',\n  TIMEOUT_ERROR: 'TIMEOUT_ERROR',\n  PLAYER_ERROR: 'PLAYER_ERROR',\n  CONTENT_NOT_FOUND: 'CONTENT_NOT_FOUND',\n  GEO_BLOCKED: 'GEO_BLOCKED',\n  QUALITY_UNAVAILABLE: 'QUALITY_UNAVAILABLE'\n};\n\n// Alternative streaming sources for fallback (November 2025)\nconst EMBED_SOURCES = {\n  vidsrc: {\n    name: 'VidSrc',\n    baseUrl: 'https://vidsrc.to/embed',\n    supports: ['movie', 'tv']\n  },\n  vidsrcdomains: {\n    name: 'VidSrc Domains',\n    baseUrl: 'https://vidsrc.domains/embed/',\n    supports: ['movie', 'tv']\n  },\n  embedsu: {\n    name: 'EmbedSu',\n    baseUrl: 'https://embedsu.com/embed/',\n    supports: ['movie', 'tv']\n  },\n  embed2: {\n    name: '2Embed',\n    baseUrl: 'https://www.2embed.cc/embed/',\n    supports: ['movie', 'tv']\n  },\n  autoembed: {\n    name: 'AutoEmbed',\n    baseUrl: 'https://autoembed.cc/embed/',\n    supports: ['movie', 'tv']\n  },\n  vidsrcsu: {\n    name: 'VidSrcSu',\n    baseUrl: 'https://vidsrcsu.com/embed/',\n    supports: ['movie', 'tv']\n  },\n  vidsrcpk: {\n    name: 'VidSrcPK',\n    baseUrl: 'https://vidsrc.pk/embed/',\n    supports: ['movie', 'tv']\n  },\n  embedsoap: {\n    name: 'EmbedSoap',\n    baseUrl: 'https://www.embedsoap.com/embed/movie/',\n    supports: ['movie']\n  },\n  smashystream: {\n    name: 'SmashyStream',\n    baseUrl: 'https://player.smashystream.com/movie/',\n    supports: ['movie']\n  },\n  multiembed: {\n    name: 'MultiEmbed',\n    baseUrl: 'https://multiembed.mov/directstream.php?video_id=',\n    supports: ['movie', 'tv']\n  },\n  vidplay: {\n    name: 'VidPlay',\n    baseUrl: 'https://vidplay.online/embed/',\n    supports: ['movie', 'tv']\n  },\n  solarmovie: {\n    name: 'SolarMovie',\n    baseUrl: 'https://www.solarmovie.pe/embed/',\n    supports: ['movie', 'tv']\n  },\n  flixhq: {\n    name: 'FlixHQ',\n    baseUrl: 'https://flixhq.to/embed/',\n    supports: ['movie', 'tv']\n  },\n  multiembed: {\n    name: 'MultiEmbed',\n    baseUrl: 'https://multiembed.mov/directstream.php?video_id=',\n    supports: ['movie', 'tv']\n  },\n  smashystream: {\n    name: 'SmashyStream',\n    baseUrl: 'https://player.smashystream.com/movie/',\n    supports: ['movie', 'tv']\n  },\n  vidplay: {\n    name: 'VidPlay',\n    baseUrl: 'https://vidplay.online/embed/',\n    supports: ['movie', 'tv']\n  },\n  fmovies: {\n    name: 'FMovies',\n    baseUrl: 'https://fmovies.to/embed/',\n    supports: ['movie', 'tv']\n  },\n  lookmovie: {\n    name: 'LookMovie',\n    baseUrl: 'https://lookmovie.io/embed/',\n    supports: ['movie', 'tv']\n  },\n  sflix: {\n    name: 'SFlix',\n    baseUrl: 'https://sflix.to/embed/',\n    supports: ['movie', 'tv']\n  },\n  embedsoap2: {\n    name: 'EmbedSoap 2',\n    baseUrl: 'https://www.embedsoap.com/embed/movie/',\n    supports: ['movie']\n  },\n  embedsoap3: {\n    name: 'EmbedSoap 3',\n    baseUrl: 'https://embedsoap.com/embed/movie/',\n    supports: ['movie']\n  }\n};\n\n// Fallback Manager Class\nclass FallbackManager {\n  constructor() {\n    this.currentIndex = 0;\n    this.retryCount = 0;\n    this.maxRetries = 3;\n    this.domainLevel = 0; // 0 = primary, 1 = fallbacks, 2 = alternative\n  }\n  getDomainsForCurrentLevel() {\n    switch (this.domainLevel) {\n      case 0:\n        return [VIDSRC_DOMAINS.primary];\n      case 1:\n        return VIDSRC_DOMAINS.fallbacks;\n      case 2:\n        return VIDSRC_DOMAINS.alternative;\n      default:\n        return [VIDSRC_DOMAINS.primary];\n    }\n  }\n  getNextUrl(type, id, season = null, episode = null, quality = 'auto') {\n    const domains = this.getDomainsForCurrentLevel();\n    const domain = domains[this.currentIndex % domains.length];\n    this.currentIndex++;\n\n    // Move to next domain level if we've tried all domains in current level\n    if (this.currentIndex >= domains.length) {\n      this.currentIndex = 0;\n      this.domainLevel = Math.min(this.domainLevel + 1, 2);\n    }\n\n    // Use correct URL patterns based on research (November 2025)\n    let baseUrl;\n\n    // Different URL patterns for different domains\n    if (domain.includes('vidsrc.to') || domain.includes('vidsrc.cc') || domain.includes('vidsrc.org') || domain.includes('vidsrc.me')) {\n      // These domains use the /embed/movie/ID pattern\n      baseUrl = type === 'movie' ? `${domain}/movie/${id}` : `${domain}/tv/${id}/${season}/${episode}`;\n    } else if (domain.includes('embedsu.com') || domain.includes('2embed.cc') || domain.includes('autoembed.cc')) {\n      // These domains use direct embed pattern\n      baseUrl = type === 'movie' ? `${domain}/${id}` : `${domain}/${id}/${season}/${episode}`;\n    } else if (domain.includes('embed.su')) {\n      // embed.su uses /embed/movie/ID pattern\n      baseUrl = type === 'movie' ? `${domain}/movie/${id}` : `${domain}/tv/${id}/${season}/${episode}`;\n    } else if (domain.includes('player.smashystream.com')) {\n      // smashystream uses /movie/ID pattern\n      baseUrl = type === 'movie' ? `${domain}/${id}` : `${domain}/${id}/${season}/${episode}`;\n    } else if (domain.includes('multiembed.mov')) {\n      // multiembed uses directstream.php pattern\n      baseUrl = type === 'movie' ? `${domain}=${id}` : `${domain}=${id}&season=${season}&episode=${episode}`;\n    } else if (domain.includes('vidplay.online')) {\n      // vidplay uses /embed/ID pattern\n      baseUrl = type === 'movie' ? `${domain}/${id}` : `${domain}/${id}?s=${season}&e=${episode}`;\n    } else if (domain.includes('embedsoap.com') || domain.includes('www.embedsoap.com')) {\n      // embedsoap uses /embed/movie/?id=ID pattern\n      baseUrl = type === 'movie' ? `${domain}?id=${id}` : `${domain}?id=${id}&s=${season}&e=${episode}`;\n    } else if (domain.includes('solarmovie.pe')) {\n      // solarmovie uses /embed/ID pattern\n      baseUrl = type === 'movie' ? `${domain}/${id}` : `${domain}/${id}?s=${season}&e=${episode}`;\n    } else if (domain.includes('flixhq.to')) {\n      // flixhq uses /embed/ID pattern\n      baseUrl = type === 'movie' ? `${domain}/${id}` : `${domain}/${id}?s=${season}&e=${episode}`;\n    } else if (domain.includes('player.smashystream.com')) {\n      // smashystream uses /movie/ID pattern\n      baseUrl = type === 'movie' ? `${domain}/${id}` : `${domain}/${id}/${season}/${episode}`;\n    } else {\n      // Default pattern for other domains\n      baseUrl = type === 'movie' ? `${domain}/movie/${id}` : `${domain}/tv/${id}/${season}/${episode}`;\n    }\n    return quality !== 'auto' ? `${baseUrl}?q=${quality}` : baseUrl;\n  }\n  recordFailure() {\n    this.retryCount++;\n    if (this.retryCount >= this.maxRetries) {\n      this.reset();\n      throw new Error('All streaming sources failed');\n    }\n  }\n  recordSuccess() {\n    this.retryCount = 0;\n    this.currentIndex = 0;\n    this.domainLevel = 0;\n  }\n  reset() {\n    this.currentIndex = 0;\n    this.retryCount = 0;\n    this.domainLevel = 0;\n  }\n  getCurrentDomain() {\n    const domains = this.getDomainsForCurrentLevel();\n    return domains[this.currentIndex % domains.length];\n  }\n}\n\n// Error Recovery Manager Class\nclass ErrorRecoveryManager {\n  constructor(fallbackManager) {\n    this.fallbackManager = fallbackManager;\n    this.recoveryStrategies = new Map();\n    this.initializeStrategies();\n  }\n  initializeStrategies() {\n    this.recoveryStrategies.set(StreamErrorTypes.NETWORK_ERROR, this.handleNetworkError.bind(this));\n    this.recoveryStrategies.set(StreamErrorTypes.TIMEOUT_ERROR, this.handleTimeoutError.bind(this));\n    this.recoveryStrategies.set(StreamErrorTypes.PLAYER_ERROR, this.handlePlayerError.bind(this));\n    this.recoveryStrategies.set(StreamErrorTypes.CONTENT_NOT_FOUND, this.handleContentNotFound.bind(this));\n    this.recoveryStrategies.set(StreamErrorTypes.QUALITY_UNAVAILABLE, this.handleQualityError.bind(this));\n  }\n  async recover(error, context) {\n    const strategy = this.recoveryStrategies.get(error.type);\n    if (strategy) {\n      return await strategy(error, context);\n    }\n    throw error;\n  }\n  async handleNetworkError(error, context) {\n    // Wait with exponential backoff\n    const delay = this.calculateBackoffDelay(context.retryCount);\n    await this.delay(delay);\n    return this.fallbackManager.getNextUrl(context.type, context.id, context.season, context.episode, context.quality);\n  }\n  async handleTimeoutError(error, context) {\n    // Reduce quality and retry\n    const newQuality = this.reduceQuality(context.quality);\n    return this.fallbackManager.getNextUrl(context.type, context.id, context.season, context.episode, newQuality);\n  }\n  async handlePlayerError(error, context) {\n    // Try different domain\n    return this.fallbackManager.getNextUrl(context.type, context.id, context.season, context.episode, context.quality);\n  }\n  async handleContentNotFound(error, context) {\n    // Try alternative sources\n    this.fallbackManager.domainLevel = 2; // Use alternative domains\n    return this.fallbackManager.getNextUrl(context.type, context.id, context.season, context.episode, context.quality);\n  }\n  async handleQualityError(error, context) {\n    // Reduce quality and retry\n    const newQuality = this.reduceQuality(context.quality);\n    return this.fallbackManager.getNextUrl(context.type, context.id, context.season, context.episode, newQuality);\n  }\n  calculateBackoffDelay(retryCount) {\n    // Enhanced exponential backoff with jitter (November 2025)\n    const baseDelay = 1000 * Math.pow(2, retryCount);\n    const jitter = Math.random() * 1000; // Add random jitter up to 1 second\n    return Math.min(baseDelay + jitter, 15000); // Max 15 seconds\n  }\n  delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  // Enhanced quality reduction strategy\n  reduceQuality(currentQuality) {\n    const qualityHierarchy = [QualityOptions.Q4K, QualityOptions.Q1080P, QualityOptions.Q720P, QualityOptions.Q480P, QualityOptions.Q360P];\n    const currentIndex = qualityHierarchy.indexOf(currentQuality);\n    if (currentIndex < qualityHierarchy.length - 1) {\n      return qualityHierarchy[currentIndex + 1];\n    }\n    return QualityOptions.Q360P;\n  }\n  reduceQuality(currentQuality) {\n    const qualityHierarchy = [QualityOptions.Q4K, QualityOptions.Q1080P, QualityOptions.Q720P, QualityOptions.Q480P, QualityOptions.Q360P];\n    const currentIndex = qualityHierarchy.indexOf(currentQuality);\n    if (currentIndex < qualityHierarchy.length - 1) {\n      return qualityHierarchy[currentIndex + 1];\n    }\n    return QualityOptions.Q360P;\n  }\n}\n\n// Performance Monitor Class\nclass PerformanceMonitor {\n  constructor() {\n    this.metrics = {\n      streamLoadTime: [],\n      bufferingEvents: [],\n      qualitySwitches: [],\n      errorRates: [],\n      userEngagement: []\n    };\n    this.startTime = null;\n  }\n  startTracking() {\n    this.startTime = Date.now();\n  }\n  trackStreamLoadTime(endTime) {\n    if (!this.startTime) return;\n    const loadTime = endTime - this.startTime;\n    this.metrics.streamLoadTime.push(loadTime);\n    if (loadTime > 10000) {\n      // 10 seconds\n      console.warn('Slow stream loading detected:', loadTime);\n    }\n  }\n  trackBufferingEvent(duration) {\n    this.metrics.bufferingEvents.push({\n      timestamp: Date.now(),\n      duration\n    });\n  }\n  trackQualitySwitch(from, to) {\n    this.metrics.qualitySwitches.push({\n      timestamp: Date.now(),\n      from,\n      to\n    });\n  }\n  trackError(error) {\n    this.metrics.errorRates.push({\n      timestamp: Date.now(),\n      error: error.message\n    });\n  }\n  generateReport() {\n    const loadTimes = this.metrics.streamLoadTime;\n    return {\n      averageLoadTime: loadTimes.length > 0 ? loadTimes.reduce((a, b) => a + b, 0) / loadTimes.length : 0,\n      bufferingFrequency: this.metrics.bufferingEvents.length,\n      qualitySwitchCount: this.metrics.qualitySwitches.length,\n      errorCount: this.metrics.errorRates.length,\n      successRate: this.calculateSuccessRate()\n    };\n  }\n  calculateSuccessRate() {\n    const totalAttempts = this.metrics.streamLoadTime.length + this.metrics.errorRates.length;\n    return totalAttempts > 0 ? this.metrics.streamLoadTime.length / totalAttempts * 100 : 0;\n  }\n}\n\n// Global instances\nconst fallbackManager = new FallbackManager();\nconst errorRecoveryManager = new ErrorRecoveryManager(fallbackManager);\nconst performanceMonitor = new PerformanceMonitor();\nexport const vidsrcApi = {\n  // Enhanced streaming URL generation with fallback support\n  getMovieStream: (tmdbId, options = {}) => {\n    const {\n      quality = 'auto',\n      useFallback = true\n    } = options;\n    try {\n      const url = useFallback ? fallbackManager.getNextUrl('movie', tmdbId, null, null, quality) : `${VIDSRC_DOMAINS.primary}/movie/${tmdbId}${quality !== 'auto' ? `?q=${quality}` : ''}`;\n      return {\n        url,\n        type: 'movie',\n        provider: 'vidsrc',\n        embeddable: true,\n        quality,\n        fallbackSupported: useFallback\n      };\n    } catch (error) {\n      return this.getErrorStream('movie', tmdbId, error);\n    }\n  },\n  // Enhanced TV streaming with fallback support\n  getTVStream: (tmdbId, season = 1, episode = 1, options = {}) => {\n    const {\n      quality = 'auto',\n      useFallback = true\n    } = options;\n    try {\n      const url = useFallback ? fallbackManager.getNextUrl('tv', tmdbId, season, episode, quality) : `${VIDSRC_DOMAINS.primary}/tv/${tmdbId}/${season}/${episode}${quality !== 'auto' ? `?q=${quality}` : ''}`;\n      return {\n        url,\n        type: 'tv',\n        provider: 'vidsrc',\n        embeddable: true,\n        season,\n        episode,\n        quality,\n        fallbackSupported: useFallback\n      };\n    } catch (error) {\n      return this.getErrorStream('tv', tmdbId, error, season, episode);\n    }\n  },\n  // Get error stream for failed requests\n  getErrorStream: (type, id, error, season = null, episode = null) => {\n    return {\n      url: '',\n      type,\n      provider: 'error',\n      embeddable: false,\n      error: error.message,\n      season,\n      episode\n    };\n  },\n  // Try alternative URL patterns for better compatibility (November 2025)\n  tryAlternativeUrls: (tmdbId, type, season = null, episode = null) => {\n    const alternatives = [];\n\n    // Try current working VidSrc domains from research\n    const domains = ['https://vidsrc.to/embed', 'https://vidsrc.cc/embed', 'https://vidsrc.org/embed', 'https://vidsrc.me/embed', 'https://vidsrc.net/embed', 'https://vidsrc.xyz/embed', 'https://vidsrc.io/embed', 'https://vidsrc.vc/embed', 'https://vidsrc.bz/embed', 'https://vidsrc.gd/embed'];\n    domains.forEach(domain => {\n      if (type === 'movie') {\n        alternatives.push(`${domain}/movie/${tmdbId}`);\n      } else {\n        alternatives.push(`${domain}/tv/${tmdbId}/${season || 1}/${episode || 1}`);\n      }\n    });\n\n    // Add alternative streaming sources\n    const altSources = [`https://embedsu.com/embed/${tmdbId}`, `https://www.2embed.cc/embed/${tmdbId}`, `https://embed.su/embed/movie/${tmdbId}`, `https://autoembed.cc/embed/${tmdbId}`, `https://vidsrcsu.com/embed/${tmdbId}`, `https://vidsrc.pk/embed/${tmdbId}`, `https://www.embedsoap.com/embed/movie/?id=${tmdbId}`, `https://player.smashystream.com/movie/${tmdbId}`, `https://multiembed.mov/directstream.php?video_id=${tmdbId}`, `https://vidplay.online/embed/${tmdbId}`, `https://www.solarmovie.pe/embed/${tmdbId}`, `https://flixhq.to/embed/${tmdbId}`];\n    alternatives.push(...altSources);\n    return alternatives;\n  },\n  // Enhanced multiple streaming sources with quality options\n  getMovieSources: (tmdbId, options = {}) => {\n    const {\n      includeAlternatives = true,\n      quality = 'auto'\n    } = options;\n    const sources = [];\n\n    // Primary VidSrc sources with different qualities\n    const qualities = [QualityOptions.Q4K, QualityOptions.Q1080P, QualityOptions.Q720P, QualityOptions.Q480P];\n    qualities.forEach((q, index) => {\n      sources.push({\n        id: `vidsrc-${q}`,\n        name: `VidSrc ${q.toUpperCase()}`,\n        url: fallbackManager.getNextUrl('movie', tmdbId, null, null, q),\n        embeddable: true,\n        quality: q,\n        provider: 'vidsrc',\n        primary: index === 0\n      });\n    });\n\n    // Backup domains for primary quality\n    if (includeAlternatives) {\n      VIDSRC_DOMAINS.fallbacks.forEach((domain, index) => {\n        sources.push({\n          id: `vidsrc-backup-${index}`,\n          name: `VidSrc Backup ${index + 1}`,\n          url: `${domain}/movie/${tmdbId}${quality !== 'auto' ? `?q=${quality}` : ''}`,\n          embeddable: true,\n          quality: quality,\n          provider: 'vidsrc',\n          backup: true\n        });\n      });\n\n      // Alternative sources - using the fallback manager for correct URL patterns\n      VIDSRC_DOMAINS.alternative.forEach((domain, index) => {\n        const sourceId = `alt-${index}`;\n        let sourceName = `Alternative ${index + 1}`;\n        let provider = `alternative-${index}`;\n\n        // Set meaningful names for known sources\n        if (domain.includes('2embed.cc')) {\n          sourceName = '2Embed';\n          provider = '2embed';\n        } else if (domain.includes('embedsu.com')) {\n          sourceName = 'EmbedSu';\n          provider = 'embedsu';\n        } else if (domain.includes('autoembed.cc')) {\n          sourceName = 'AutoEmbed';\n          provider = 'autoembed';\n        } else if (domain.includes('embed.su')) {\n          sourceName = 'Embed.su';\n          provider = 'embedsu';\n        } else if (domain.includes('smashystream.com')) {\n          sourceName = 'SmashyStream';\n          provider = 'smashystream';\n        } else if (domain.includes('multiembed.mov')) {\n          sourceName = 'MultiEmbed';\n          provider = 'multiembed';\n        } else if (domain.includes('vidplay.online')) {\n          sourceName = 'VidPlay';\n          provider = 'vidplay';\n        } else if (domain.includes('embedsoap.com')) {\n          sourceName = 'EmbedSoap';\n          provider = 'embedsoap';\n        } else if (domain.includes('solarmovie.pe')) {\n          sourceName = 'SolarMovie';\n          provider = 'solarmovie';\n        } else if (domain.includes('flixhq.to')) {\n          sourceName = 'FlixHQ';\n          provider = 'flixhq';\n        } else if (domain.includes('multiembed.mov')) {\n          sourceName = 'MultiEmbed';\n          provider = 'multiembed';\n        } else if (domain.includes('player.smashystream.com')) {\n          sourceName = 'SmashyStream';\n          provider = 'smashystream';\n        }\n        sources.push({\n          id: sourceId,\n          name: sourceName,\n          url: fallbackManager.getNextUrl('movie', tmdbId, null, null, quality),\n          embeddable: true,\n          quality: 'HD',\n          provider: provider,\n          alternative: true\n        });\n      });\n    }\n    return sources;\n  },\n  // Enhanced TV sources with quality options\n  getTVSources: (tmdbId, season = 1, episode = 1, options = {}) => {\n    const {\n      includeAlternatives = true,\n      quality = 'auto'\n    } = options;\n    const sources = [];\n\n    // Primary VidSrc sources with different qualities\n    const qualities = [QualityOptions.Q1080P, QualityOptions.Q720P, QualityOptions.Q480P];\n    qualities.forEach((q, index) => {\n      sources.push({\n        id: `vidsrc-${q}`,\n        name: `VidSrc ${q.toUpperCase()}`,\n        url: fallbackManager.getNextUrl('tv', tmdbId, season, episode, q),\n        embeddable: true,\n        quality: q,\n        provider: 'vidsrc',\n        season,\n        episode,\n        primary: index === 0\n      });\n    });\n\n    // Backup domains for primary quality\n    if (includeAlternatives) {\n      VIDSRC_DOMAINS.fallbacks.forEach((domain, index) => {\n        sources.push({\n          id: `vidsrc-backup-${index}`,\n          name: `VidSrc Backup ${index + 1}`,\n          url: `${domain}/tv/${tmdbId}/${season}/${episode}${quality !== 'auto' ? `?q=${quality}` : ''}`,\n          embeddable: true,\n          quality: quality,\n          provider: 'vidsrc',\n          season,\n          episode,\n          backup: true\n        });\n      });\n    }\n    return sources;\n  },\n  // Check if streaming is available for a movie\n  checkAvailability: async (tmdbId, type = 'movie') => {\n    try {\n      // VidSrc doesn't have a formal availability check API\n      // We assume content is available if it has a valid TMDB ID\n      return {\n        available: true,\n        provider: 'vidsrc',\n        embeddable: true,\n        message: 'Streaming available via VidSrc'\n      };\n    } catch (error) {\n      return {\n        available: false,\n        provider: 'vidsrc',\n        embeddable: false,\n        message: 'Streaming temporarily unavailable'\n      };\n    }\n  },\n  // Get streaming quality information\n  getQualityInfo: () => {\n    return {\n      default: '1080p',\n      available: ['720p', '1080p', '4K'],\n      note: 'Quality automatically adjusts based on connection speed'\n    };\n  },\n  // Get supported regions\n  getSupportedRegions: () => {\n    return {\n      regions: ['IN', 'US', 'UK', 'CA', 'AU', 'DE', 'FR', 'JP', 'KR', 'BR', 'MX', 'ES', 'IT', 'NL', 'SE', 'NO', 'DK', 'FI', 'PL', 'RU', 'CN', 'HK', 'TW', 'SG', 'MY', 'TH', 'VN', 'PH', 'ID', 'AE', 'SA', 'EG', 'ZA', 'NG', 'KE', 'MA', 'TN', 'DZ', 'AR', 'CL', 'CO', 'PE', 'VE', 'EC', 'UY', 'PY', 'BO', 'GT', 'CR', 'PA', 'DO', 'JM', 'TT', 'BB', 'LC', 'VC', 'GD', 'AG', 'DM', 'KN', 'MS', 'VG', 'AI', 'BM', 'KY', 'TC', 'FK', 'GS', 'SH', 'IO', 'AC', 'TA', 'PN', 'WF', 'PF', 'NC', 'VU', 'FJ', 'PG', 'SB', 'KI', 'NR', 'TV', 'TO', 'WS', 'CK', 'NU', 'TK', 'AS', 'GU', 'MP', 'FM', 'MH', 'PW', 'UM', 'VI', 'PR'],\n      note: 'VidSrc works globally with no regional restrictions'\n    };\n  },\n  // Enhanced error handling with recovery\n  handleStreamError: async (error, context) => {\n    performanceMonitor.trackError(error);\n    try {\n      const recoveredUrl = await errorRecoveryManager.recover(error, context);\n      fallbackManager.recordSuccess();\n      return {\n        success: true,\n        url: recoveredUrl,\n        recovered: true\n      };\n    } catch (recoveryError) {\n      fallbackManager.recordFailure();\n      return {\n        success: false,\n        error: recoveryError.message,\n        fallbackExhausted: true\n      };\n    }\n  },\n  // Get available quality options\n  getQualityOptions: (contentType = 'movie') => {\n    const baseQualities = [QualityOptions.Q1080P, QualityOptions.Q720P, QualityOptions.Q480P];\n    if (contentType === 'movie') {\n      baseQualities.unshift(QualityOptions.Q4K);\n    }\n    return baseQualities;\n  },\n  // Test stream availability with enhanced error handling (November 2025)\n  testStream: async (url, timeout = 8000) => {\n    const startTime = Date.now();\n\n    // Create a timeout promise with AbortController for better control\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n    try {\n      // Try HEAD request first (more efficient)\n      const response = await fetch(url, {\n        method: 'HEAD',\n        signal: controller.signal,\n        headers: {\n          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n        }\n      });\n      clearTimeout(timeoutId);\n      const loadTime = Date.now() - startTime;\n      performanceMonitor.trackStreamLoadTime(Date.now());\n\n      // Check if response is successful and content exists\n      if (response.ok && response.status < 400) {\n        return {\n          available: true,\n          loadTime,\n          url,\n          responseTime: loadTime,\n          method: 'HEAD',\n          status: response.status\n        };\n      } else {\n        return {\n          available: false,\n          loadTime,\n          error: `HTTP ${response.status}: ${response.statusText}`,\n          errorType: response.status === 404 ? StreamErrorTypes.CONTENT_NOT_FOUND : StreamErrorTypes.PLAYER_ERROR,\n          url,\n          responseTime: loadTime,\n          method: 'HEAD',\n          status: response.status,\n          retryable: response.status !== 404\n        };\n      }\n    } catch (headError) {\n      try {\n        // If HEAD fails, try GET request to actually check content\n        const getResponse = await fetch(url, {\n          method: 'GET',\n          signal: controller.signal,\n          headers: {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n          }\n        });\n        clearTimeout(timeoutId);\n        const loadTime = Date.now() - startTime;\n        performanceMonitor.trackStreamLoadTime(Date.now());\n\n        // Check if response is successful\n        if (getResponse.ok && getResponse.status < 400) {\n          // Try to read response text to verify it's not an error page\n          const responseText = await getResponse.text();\n          const contentLength = responseText.length;\n\n          // Basic checks for video availability\n          const hasVideoContent = contentLength > 1000; // Minimum content length\n          const isErrorPage = responseText.includes('not found') || responseText.includes('video not available') || responseText.includes('error') || responseText.includes('404') || responseText.includes('Video not found');\n          if (hasVideoContent && !isErrorPage) {\n            return {\n              available: true,\n              loadTime,\n              url,\n              responseTime: loadTime,\n              method: 'GET',\n              status: getResponse.status,\n              contentLength\n            };\n          } else {\n            return {\n              available: false,\n              loadTime,\n              error: isErrorPage ? 'Video not found on server' : 'Insufficient content or error page detected',\n              errorType: StreamErrorTypes.CONTENT_NOT_FOUND,\n              url,\n              responseTime: loadTime,\n              method: 'GET',\n              status: getResponse.status,\n              contentLength,\n              retryable: false\n            };\n          }\n        } else {\n          return {\n            available: false,\n            loadTime,\n            error: `HTTP ${getResponse.status}: ${getResponse.statusText}`,\n            errorType: getResponse.status === 404 ? StreamErrorTypes.CONTENT_NOT_FOUND : StreamErrorTypes.PLAYER_ERROR,\n            url,\n            responseTime: loadTime,\n            method: 'GET',\n            status: getResponse.status,\n            retryable: getResponse.status !== 404\n          };\n        }\n      } catch (getError) {\n        clearTimeout(timeoutId);\n        const loadTime = Date.now() - startTime;\n        performanceMonitor.trackStreamLoadTime(Date.now());\n\n        // Enhanced error classification based on November 2025 standards\n        let errorType = StreamErrorTypes.NETWORK_ERROR;\n        let errorMessage = getError.message;\n        if (getError.name === 'AbortError' || getError.message.includes('timeout') || getError.message.includes('aborted')) {\n          errorType = StreamErrorTypes.TIMEOUT_ERROR;\n          errorMessage = 'Request timeout - server took too long to respond';\n        } else if (getError.message.includes('404') || getError.message.includes('Not Found')) {\n          errorType = StreamErrorTypes.CONTENT_NOT_FOUND;\n          errorMessage = 'Video not found on this server';\n        } else if (getError.message.includes('403') || getError.message.includes('Forbidden')) {\n          errorType = StreamErrorTypes.GEO_BLOCKED;\n          errorMessage = 'Content blocked in your region';\n        } else if (getError.message.includes('NetworkError') || getError.message.includes('Failed to fetch')) {\n          errorType = StreamErrorTypes.NETWORK_ERROR;\n          errorMessage = 'Network connection failed';\n        }\n        return {\n          available: false,\n          loadTime,\n          error: errorMessage,\n          errorType,\n          url,\n          responseTime: loadTime,\n          retryable: errorType !== StreamErrorTypes.CONTENT_NOT_FOUND\n        };\n      }\n    }\n  },\n  // Get performance metrics\n  getPerformanceReport: () => {\n    return performanceMonitor.generateReport();\n  },\n  // Test multiple sources and return the first working one\n  testMultipleSources: async (sources, options = {}) => {\n    const {\n      timeout = 8000,\n      maxConcurrent = 3\n    } = options;\n    const workingSources = [];\n    const failedSources = [];\n    console.log(`🔍 [DEBUG] Starting comprehensive source testing`);\n    console.log(`🔍 [DEBUG] Total sources: ${sources.length}, Timeout: ${timeout}ms, Max concurrent: ${maxConcurrent}`);\n\n    // Test sources in batches to avoid overwhelming servers\n    for (let i = 0; i < sources.length; i += maxConcurrent) {\n      const batch = sources.slice(i, i + maxConcurrent);\n      console.log(`🔍 [DEBUG] Testing batch ${Math.floor(i / maxConcurrent) + 1}/${Math.ceil(sources.length / maxConcurrent)}`);\n      const batchPromises = batch.map(async source => {\n        const startTime = Date.now();\n        try {\n          console.log(`🔍 [DEBUG] Testing: ${source.name || source.id} (${source.provider})`);\n          const result = await vidsrcApi.testStream(source.url, timeout);\n          const testTime = Date.now() - startTime;\n          console.log(`🔍 [DEBUG] Result: ${result.available ? '✅' : '❌'} ${source.name || source.id} (${testTime}ms)`);\n          return {\n            source,\n            result\n          };\n        } catch (error) {\n          const testTime = Date.now() - startTime;\n          console.log(`🔍 [DEBUG] Error: ❌ ${source.name || source.id} - ${error.message} (${testTime}ms)`);\n          return {\n            source,\n            result: {\n              available: false,\n              error: error.message,\n              errorType: 'TEST_ERROR'\n            }\n          };\n        }\n      });\n      const batchResults = await Promise.all(batchPromises);\n      batchResults.forEach(({\n        source,\n        result\n      }) => {\n        if (result.available) {\n          workingSources.push({\n            ...source,\n            testResult: result\n          });\n          console.log(`✅ [DEBUG] Working source found: ${source.name || source.id}`);\n        } else {\n          failedSources.push({\n            ...source,\n            testResult: result\n          });\n          console.log(`❌ [DEBUG] Failed source: ${source.name || source.id} - ${result.error || 'Unknown error'}`);\n        }\n      });\n    }\n    const successRate = sources.length > 0 ? workingSources.length / sources.length * 100 : 0;\n    console.log(`📊 [DEBUG] Testing complete: ${workingSources.length}/${sources.length} working (${successRate.toFixed(1)}%)`);\n    return {\n      working: workingSources,\n      failed: failedSources,\n      total: sources.length,\n      successRate\n    };\n  },\n  // Enhanced method to find the first working source quickly\n  findFirstWorkingSource: async (sources, options = {}) => {\n    const {\n      timeout = 5000,\n      maxConcurrent = 5\n    } = options;\n    console.log(`🔍 [DEBUG] Starting source testing for ${sources.length} sources`);\n    console.log(`🔍 [DEBUG] Timeout: ${timeout}ms, Max concurrent: ${maxConcurrent}`);\n\n    // Test sources in parallel batches\n    for (let i = 0; i < sources.length; i += maxConcurrent) {\n      const batch = sources.slice(i, i + maxConcurrent);\n      console.log(`🔍 [DEBUG] Testing batch ${Math.floor(i / maxConcurrent) + 1}: ${batch.map(s => s.name || s.id).join(', ')}`);\n      const batchPromises = batch.map(async source => {\n        const startTime = Date.now();\n        try {\n          console.log(`🔍 [DEBUG] Testing source: ${source.name || source.id} - ${source.url}`);\n          const result = await vidsrcApi.testStream(source.url, timeout);\n          const testTime = Date.now() - startTime;\n          console.log(`🔍 [DEBUG] Source ${source.name || source.id}: ${result.available ? '✅ AVAILABLE' : '❌ FAILED'} (${testTime}ms)`);\n          if (!result.available) {\n            console.log(`🔍 [DEBUG] Source ${source.name || source.id} failed: ${result.error || 'Unknown error'}`);\n          }\n          if (result.available) {\n            return {\n              source,\n              result,\n              success: true\n            };\n          }\n          return {\n            source,\n            result,\n            success: false\n          };\n        } catch (error) {\n          const testTime = Date.now() - startTime;\n          console.log(`🔍 [DEBUG] Source ${source.name || source.id} error: ${error.message} (${testTime}ms)`);\n          return {\n            source,\n            result: {\n              available: false,\n              error: error.message\n            },\n            success: false\n          };\n        }\n      });\n      const batchResults = await Promise.all(batchPromises);\n\n      // Return the first working source found\n      const workingSource = batchResults.find(result => result.success);\n      if (workingSource) {\n        console.log(`🎉 [DEBUG] Found working source: ${workingSource.source.name || workingSource.source.id}`);\n        console.log(`🎉 [DEBUG] URL: ${workingSource.source.url}`);\n        console.log(`🎉 [DEBUG] Provider: ${workingSource.source.provider}`);\n        return workingSource;\n      }\n    }\n    console.log(`❌ [DEBUG] No working sources found after testing all ${sources.length} sources`);\n    return null; // No working sources found\n  },\n  // Get best available source with automatic testing\n  getBestAvailableSource: async (tmdbId, type, season = null, episode = null, options = {}) => {\n    const {\n      testSources = true,\n      quality = 'auto'\n    } = options;\n\n    // Get all available sources\n    const sources = type === 'movie' ? vidsrcApi.getMovieSources(tmdbId, {\n      includeAlternatives: true,\n      quality\n    }) : vidsrcApi.getTVSources(tmdbId, season, episode, {\n      includeAlternatives: true,\n      quality\n    });\n    if (!testSources) {\n      return sources[0]; // Return first source without testing\n    }\n\n    // Test sources and return the first working one\n    const testResult = await vidsrcApi.testMultipleSources(sources);\n    if (testResult.working.length > 0) {\n      return testResult.working[0];\n    }\n\n    // If no sources work, return the primary source with error info\n    return {\n      ...sources[0],\n      testResult: {\n        available: false,\n        error: 'No working sources found',\n        errorType: 'ALL_SOURCES_FAILED'\n      }\n    };\n  },\n  // Reset fallback manager\n  resetFallbackManager: () => {\n    fallbackManager.reset();\n    performanceMonitor.startTracking();\n  },\n  // Get current fallback status\n  getFallbackStatus: () => {\n    return {\n      currentDomain: fallbackManager.getCurrentDomain(),\n      retryCount: fallbackManager.retryCount,\n      domainLevel: fallbackManager.domainLevel,\n      maxRetries: fallbackManager.maxRetries\n    };\n  },\n  // Manual source verification as backup when automatic testing fails\n  verifySourceManually: async (url, timeout = 10000) => {\n    console.log(`🔍 [Manual] Starting manual verification for: ${url}`);\n    return new Promise(resolve => {\n      const iframe = document.createElement('iframe');\n      iframe.src = url;\n      iframe.style.display = 'none';\n      iframe.sandbox = 'allow-same-origin allow-scripts allow-presentation';\n      const startTime = Date.now();\n      let hasLoaded = false;\n      let hasError = false;\n      const cleanup = () => {\n        if (iframe.parentNode) {\n          iframe.parentNode.removeChild(iframe);\n        }\n        clearTimeout(timeoutId);\n      };\n      const timeoutId = setTimeout(() => {\n        if (!hasLoaded && !hasError) {\n          console.log(`⏱️ [Manual] Manual verification timeout for: ${url}`);\n          cleanup();\n          resolve({\n            available: false,\n            error: 'Manual verification timeout',\n            errorType: 'TIMEOUT_ERROR',\n            method: 'manual-iframe',\n            loadTime: Date.now() - startTime\n          });\n        }\n      }, timeout);\n      iframe.onload = () => {\n        hasLoaded = true;\n        const loadTime = Date.now() - startTime;\n        console.log(`✅ [Manual] Manual verification success for: ${url} (${loadTime}ms)`);\n\n        // Additional check: try to access iframe content\n        try {\n          const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\n          const hasVideoElement = iframeDoc.querySelector('video') !== null;\n          const hasPlayerContainer = iframeDoc.querySelector('.player, #player, [class*=\"player\"]') !== null;\n          const isErrorPage = iframeDoc.body && iframeDoc.body.textContent.includes('not found');\n          if (isErrorPage) {\n            cleanup();\n            resolve({\n              available: false,\n              error: 'Video not found (detected error page)',\n              errorType: 'CONTENT_NOT_FOUND',\n              method: 'manual-iframe',\n              loadTime,\n              hasVideoElement,\n              hasPlayerContainer\n            });\n          } else if (hasVideoElement || hasPlayerContainer) {\n            cleanup();\n            resolve({\n              available: true,\n              loadTime,\n              method: 'manual-iframe',\n              hasVideoElement,\n              hasPlayerContainer\n            });\n          } else {\n            // Give it a bit more time to load video content\n            setTimeout(() => {\n              try {\n                const finalDoc = iframe.contentDocument || iframe.contentWindow.document;\n                const finalVideoElement = finalDoc.querySelector('video') !== null;\n                const finalPlayerContainer = finalDoc.querySelector('.player, #player, [class*=\"player\"]') !== null;\n                cleanup();\n                resolve({\n                  available: finalVideoElement || finalPlayerContainer,\n                  loadTime: Date.now() - startTime,\n                  method: 'manual-iframe',\n                  hasVideoElement: finalVideoElement,\n                  hasPlayerContainer: finalPlayerContainer\n                });\n              } catch (e) {\n                cleanup();\n                resolve({\n                  available: true,\n                  // Assume it's working if we can't check content\n                  loadTime: Date.now() - startTime,\n                  method: 'manual-iframe',\n                  note: 'Could not verify content due to CORS, assuming available'\n                });\n              }\n            }, 2000);\n          }\n        } catch (e) {\n          // CORS restriction - assume it's working if it loaded\n          cleanup();\n          resolve({\n            available: true,\n            loadTime,\n            method: 'manual-iframe',\n            note: 'Could not verify content due to CORS, assuming available'\n          });\n        }\n      };\n      iframe.onerror = () => {\n        hasError = true;\n        const loadTime = Date.now() - startTime;\n        console.log(`❌ [Manual] Manual verification failed for: ${url} (${loadTime}ms)`);\n        cleanup();\n        resolve({\n          available: false,\n          error: 'Failed to load iframe',\n          errorType: 'NETWORK_ERROR',\n          method: 'manual-iframe',\n          loadTime\n        });\n      };\n      document.body.appendChild(iframe);\n    });\n  },\n  // Create secure iframe embed\n  createSecureEmbed: (streamData, options = {}) => {\n    const {\n      width = '100%',\n      height = '500',\n      autoplay = false,\n      muted = false,\n      controls = true,\n      sandbox = 'allow-same-origin allow-scripts allow-presentation'\n    } = options;\n    const embedUrl = streamData.url;\n    return {\n      iframe: `<iframe\n        src=\"${embedUrl}\"\n        width=\"${width}\"\n        height=\"${height}\"\n        frameborder=\"0\"\n        allowfullscreen\n        ${autoplay ? 'autoplay' : ''}\n        ${muted ? 'muted' : ''}\n        ${controls ? '' : 'controls=\"false\"'}\n        sandbox=\"${sandbox}\"\n        allow=\"autoplay; encrypted-media; fullscreen; picture-in-picture\"\n        referrerpolicy=\"strict-origin-when-cross-origin\"\n        loading=\"lazy\"\n      ></iframe>`,\n      url: embedUrl,\n      type: streamData.type,\n      provider: streamData.provider,\n      security: {\n        sandbox,\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        cspCompliant: true\n      }\n    };\n  }\n};\n\n// Helper function to create iframe embed code\nexport const createEmbedCode = (streamData, options = {}) => {\n  const {\n    width = '100%',\n    height = '500',\n    autoplay = false,\n    muted = false,\n    controls = true\n  } = options;\n  const embedUrl = streamData.url;\n  return {\n    iframe: `<iframe\n      src=\"${embedUrl}\"\n      width=\"${width}\"\n      height=\"${height}\"\n      frameborder=\"0\"\n      allowfullscreen\n      ${autoplay ? 'autoplay' : ''}\n      ${muted ? 'muted' : ''}\n      ${controls ? '' : 'controls=\"false\"'}\n      sandbox=\"allow-same-origin allow-scripts allow-presentation\"\n    ></iframe>`,\n    url: embedUrl,\n    type: streamData.type,\n    provider: streamData.provider\n  };\n};\n\n// Error handling for streaming\nexport const handleStreamError = (error, fallbackSources = []) => {\n  console.error('Streaming error:', error);\n  if (fallbackSources.length > 0) {\n    return {\n      success: false,\n      error: error.message,\n      fallback: fallbackSources[0],\n      hasFallback: true\n    };\n  }\n  return {\n    success: false,\n    error: error.message,\n    hasFallback: false\n  };\n};\nexport default vidsrcApi;\n\n// Test function to verify video streaming functionality\nexport const testVideoStreaming = async () => {\n  console.log('🧪 Testing Video Streaming Functionality...');\n\n  // Test data - specific movies mentioned by user\n  const testMovies = [{\n    id: '278',\n    name: 'Shawshank Redemption'\n  }, {\n    id: '155',\n    name: 'The Dark Knight'\n  }, {\n    id: '550',\n    name: 'Fight Club'\n  }];\n  const testTVId = '1399'; // Game of Thrones\n\n  try {\n    // Test 1: Get movie sources for each test movie\n    console.log('\\n📽️ Testing Movie Sources...');\n    for (const movie of testMovies) {\n      const movieSources = vidsrcApi.getMovieSources(movie.id, {\n        includeAlternatives: true\n      });\n      console.log(`Found ${movieSources.length} sources for ${movie.name} (${movie.id})`);\n    }\n\n    // Test 2: Get TV sources\n    console.log('\\n📺 Testing TV Sources...');\n    const tvSources = vidsrcApi.getTVSources(testTVId, 1, 1, {\n      includeAlternatives: true\n    });\n    console.log(`Found ${tvSources.length} TV sources`);\n\n    // Test 3: Test specific movies for availability\n    console.log('\\n🔍 Testing Specific Movie Availability...');\n    for (const movie of testMovies) {\n      console.log(`\\n--- Testing ${movie.name} (${movie.id}) ---`);\n\n      // Test the primary source\n      const primaryStream = vidsrcApi.getMovieStream(movie.id, {\n        quality: '1080p'\n      });\n      console.log(`Primary URL: ${primaryStream.url}`);\n      try {\n        const result = await vidsrcApi.testStream(primaryStream.url, 5000);\n        console.log(`✅ Primary: ${result.available ? 'Available' : 'Failed'} (${result.loadTime}ms)`);\n        if (result.available) {\n          console.log(`🎉 SUCCESS: ${movie.name} is working!`);\n        } else {\n          console.log(`❌ Primary failed, trying alternatives...`);\n\n          // Try alternative sources\n          const altUrls = vidsrcApi.tryAlternativeUrls(movie.id, 'movie');\n          console.log(`Found ${altUrls.length} alternative URLs`);\n          for (let i = 0; i < Math.min(3, altUrls.length); i++) {\n            try {\n              const altResult = await vidsrcApi.testStream(altUrls[i], 3000);\n              console.log(`  Alt ${i + 1}: ${altResult.available ? 'Available' : 'Failed'} (${altResult.loadTime}ms)`);\n              if (altResult.available) {\n                console.log(`  🎉 Alternative ${i + 1} works!`);\n                break;\n              }\n            } catch (altError) {\n              console.log(`  Alt ${i + 1}: Error - ${altError.message}`);\n            }\n          }\n        }\n      } catch (error) {\n        console.log(`❌ Error testing ${movie.name}: ${error.message}`);\n      }\n    }\n\n    // Test 4: Test fallback system\n    console.log('\\n🔄 Testing Fallback System...');\n    const fallbackStatus = vidsrcApi.getFallbackStatus();\n    console.log('Fallback Status:', fallbackStatus);\n    console.log('\\n✅ Video streaming test completed!');\n    return {\n      success: true,\n      testedMovies: testMovies.length,\n      tvSources: tvSources.length\n    };\n  } catch (error) {\n    console.error('❌ Video streaming test failed:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n};","map":{"version":3,"names":["VIDSRC_DOMAINS","primary","fallbacks","QualityOptions","AUTO","Q4K","Q1080P","Q720P","Q480P","Q360P","StreamErrorTypes","NETWORK_ERROR","TIMEOUT_ERROR","PLAYER_ERROR","CONTENT_NOT_FOUND","GEO_BLOCKED","QUALITY_UNAVAILABLE","EMBED_SOURCES","vidsrc","name","baseUrl","supports","vidsrcdomains","embedsu","embed2","autoembed","vidsrcsu","vidsrcpk","embedsoap","smashystream","multiembed","vidplay","solarmovie","flixhq","fmovies","lookmovie","sflix","embedsoap2","embedsoap3","FallbackManager","constructor","currentIndex","retryCount","maxRetries","domainLevel","getDomainsForCurrentLevel","alternative","getNextUrl","type","id","season","episode","quality","domains","domain","length","Math","min","includes","recordFailure","reset","Error","recordSuccess","getCurrentDomain","ErrorRecoveryManager","fallbackManager","recoveryStrategies","Map","initializeStrategies","set","handleNetworkError","bind","handleTimeoutError","handlePlayerError","handleContentNotFound","handleQualityError","recover","error","context","strategy","get","delay","calculateBackoffDelay","newQuality","reduceQuality","baseDelay","pow","jitter","random","ms","Promise","resolve","setTimeout","currentQuality","qualityHierarchy","indexOf","PerformanceMonitor","metrics","streamLoadTime","bufferingEvents","qualitySwitches","errorRates","userEngagement","startTime","startTracking","Date","now","trackStreamLoadTime","endTime","loadTime","push","console","warn","trackBufferingEvent","duration","timestamp","trackQualitySwitch","from","to","trackError","message","generateReport","loadTimes","averageLoadTime","reduce","a","b","bufferingFrequency","qualitySwitchCount","errorCount","successRate","calculateSuccessRate","totalAttempts","errorRecoveryManager","performanceMonitor","vidsrcApi","getMovieStream","tmdbId","options","useFallback","url","provider","embeddable","fallbackSupported","getErrorStream","getTVStream","tryAlternativeUrls","alternatives","forEach","altSources","getMovieSources","includeAlternatives","sources","qualities","q","index","toUpperCase","backup","sourceId","sourceName","getTVSources","checkAvailability","available","getQualityInfo","default","note","getSupportedRegions","regions","handleStreamError","recoveredUrl","success","recovered","recoveryError","fallbackExhausted","getQualityOptions","contentType","baseQualities","unshift","testStream","timeout","controller","AbortController","timeoutId","abort","response","fetch","method","signal","headers","clearTimeout","ok","status","responseTime","statusText","errorType","retryable","headError","getResponse","responseText","text","contentLength","hasVideoContent","isErrorPage","getError","errorMessage","getPerformanceReport","testMultipleSources","maxConcurrent","workingSources","failedSources","log","i","batch","slice","floor","ceil","batchPromises","map","source","result","testTime","batchResults","all","testResult","toFixed","working","failed","total","findFirstWorkingSource","s","join","workingSource","find","getBestAvailableSource","testSources","resetFallbackManager","getFallbackStatus","currentDomain","verifySourceManually","iframe","document","createElement","src","style","display","sandbox","hasLoaded","hasError","cleanup","parentNode","removeChild","onload","iframeDoc","contentDocument","contentWindow","hasVideoElement","querySelector","hasPlayerContainer","body","textContent","finalDoc","finalVideoElement","finalPlayerContainer","e","onerror","appendChild","createSecureEmbed","streamData","width","height","autoplay","muted","controls","embedUrl","security","referrerPolicy","cspCompliant","createEmbedCode","fallbackSources","fallback","hasFallback","testVideoStreaming","testMovies","testTVId","movie","movieSources","tvSources","primaryStream","altUrls","altResult","altError","fallbackStatus","testedMovies"],"sources":["c:/Users/VASU/Desktop/task/src/services/vidsrcApi.js"],"sourcesContent":["// VidSrc API service for streaming integration\r\n// No API key required - uses TMDB IDs directly\r\n\r\n// Simplified domain configuration - vidsrc.net as primary source\r\nconst VIDSRC_DOMAINS = {\r\n  primary: 'https://vidsrc.net/embed',\r\n  fallbacks: [\r\n    'https://vidsrc.to/embed',\r\n    'https://vidsrc.cc/embed'\r\n  ]\r\n};\r\n\r\n// Quality options for streaming\r\nconst QualityOptions = {\r\n  AUTO: 'auto',\r\n  Q4K: '4k',\r\n  Q1080P: '1080p',\r\n  Q720P: '720p',\r\n  Q480P: '480p',\r\n  Q360P: '360p'\r\n};\r\n\r\n// Error types for better error handling\r\nconst StreamErrorTypes = {\r\n  NETWORK_ERROR: 'NETWORK_ERROR',\r\n  TIMEOUT_ERROR: 'TIMEOUT_ERROR',\r\n  PLAYER_ERROR: 'PLAYER_ERROR',\r\n  CONTENT_NOT_FOUND: 'CONTENT_NOT_FOUND',\r\n  GEO_BLOCKED: 'GEO_BLOCKED',\r\n  QUALITY_UNAVAILABLE: 'QUALITY_UNAVAILABLE'\r\n};\r\n\r\n// Alternative streaming sources for fallback (November 2025)\r\nconst EMBED_SOURCES = {\r\n  vidsrc: {\r\n    name: 'VidSrc',\r\n    baseUrl: 'https://vidsrc.to/embed',\r\n    supports: ['movie', 'tv']\r\n  },\r\n  vidsrcdomains: {\r\n    name: 'VidSrc Domains',\r\n    baseUrl: 'https://vidsrc.domains/embed/',\r\n    supports: ['movie', 'tv']\r\n  },\r\n  embedsu: {\r\n    name: 'EmbedSu',\r\n    baseUrl: 'https://embedsu.com/embed/',\r\n    supports: ['movie', 'tv']\r\n  },\r\n  embed2: {\r\n    name: '2Embed',\r\n    baseUrl: 'https://www.2embed.cc/embed/',\r\n    supports: ['movie', 'tv']\r\n  },\r\n  autoembed: {\r\n    name: 'AutoEmbed',\r\n    baseUrl: 'https://autoembed.cc/embed/',\r\n    supports: ['movie', 'tv']\r\n  },\r\n  vidsrcsu: {\r\n    name: 'VidSrcSu',\r\n    baseUrl: 'https://vidsrcsu.com/embed/',\r\n    supports: ['movie', 'tv']\r\n  },\r\n  vidsrcpk: {\r\n    name: 'VidSrcPK',\r\n    baseUrl: 'https://vidsrc.pk/embed/',\r\n    supports: ['movie', 'tv']\r\n  },\r\n  embedsoap: {\r\n    name: 'EmbedSoap',\r\n    baseUrl: 'https://www.embedsoap.com/embed/movie/',\r\n    supports: ['movie']\r\n  },\r\n  smashystream: {\r\n    name: 'SmashyStream',\r\n    baseUrl: 'https://player.smashystream.com/movie/',\r\n    supports: ['movie']\r\n  },\r\n  multiembed: {\r\n    name: 'MultiEmbed',\r\n    baseUrl: 'https://multiembed.mov/directstream.php?video_id=',\r\n    supports: ['movie', 'tv']\r\n  },\r\n  vidplay: {\r\n    name: 'VidPlay',\r\n    baseUrl: 'https://vidplay.online/embed/',\r\n    supports: ['movie', 'tv']\r\n  },\r\n  solarmovie: {\r\n    name: 'SolarMovie',\r\n    baseUrl: 'https://www.solarmovie.pe/embed/',\r\n    supports: ['movie', 'tv']\r\n  },\r\n  flixhq: {\r\n    name: 'FlixHQ',\r\n    baseUrl: 'https://flixhq.to/embed/',\r\n    supports: ['movie', 'tv']\r\n  },\r\n  multiembed: {\r\n    name: 'MultiEmbed',\r\n    baseUrl: 'https://multiembed.mov/directstream.php?video_id=',\r\n    supports: ['movie', 'tv']\r\n  },\r\n  smashystream: {\r\n    name: 'SmashyStream',\r\n    baseUrl: 'https://player.smashystream.com/movie/',\r\n    supports: ['movie', 'tv']\r\n  },\r\n  vidplay: {\r\n    name: 'VidPlay',\r\n    baseUrl: 'https://vidplay.online/embed/',\r\n    supports: ['movie', 'tv']\r\n  },\r\n  fmovies: {\r\n    name: 'FMovies',\r\n    baseUrl: 'https://fmovies.to/embed/',\r\n    supports: ['movie', 'tv']\r\n  },\r\n  lookmovie: {\r\n    name: 'LookMovie',\r\n    baseUrl: 'https://lookmovie.io/embed/',\r\n    supports: ['movie', 'tv']\r\n  },\r\n  sflix: {\r\n    name: 'SFlix',\r\n    baseUrl: 'https://sflix.to/embed/',\r\n    supports: ['movie', 'tv']\r\n  },\r\n  embedsoap2: {\r\n    name: 'EmbedSoap 2',\r\n    baseUrl: 'https://www.embedsoap.com/embed/movie/',\r\n    supports: ['movie']\r\n  },\r\n  embedsoap3: {\r\n    name: 'EmbedSoap 3',\r\n    baseUrl: 'https://embedsoap.com/embed/movie/',\r\n    supports: ['movie']\r\n  }\r\n};\r\n\r\n// Fallback Manager Class\r\nclass FallbackManager {\r\n  constructor() {\r\n    this.currentIndex = 0;\r\n    this.retryCount = 0;\r\n    this.maxRetries = 3;\r\n    this.domainLevel = 0; // 0 = primary, 1 = fallbacks, 2 = alternative\r\n  }\r\n\r\n  getDomainsForCurrentLevel() {\r\n    switch (this.domainLevel) {\r\n      case 0:\r\n        return [VIDSRC_DOMAINS.primary];\r\n      case 1:\r\n        return VIDSRC_DOMAINS.fallbacks;\r\n      case 2:\r\n        return VIDSRC_DOMAINS.alternative;\r\n      default:\r\n        return [VIDSRC_DOMAINS.primary];\r\n    }\r\n  }\r\n\r\n  getNextUrl(type, id, season = null, episode = null, quality = 'auto') {\r\n    const domains = this.getDomainsForCurrentLevel();\r\n    const domain = domains[this.currentIndex % domains.length];\r\n\r\n    this.currentIndex++;\r\n\r\n    // Move to next domain level if we've tried all domains in current level\r\n    if (this.currentIndex >= domains.length) {\r\n      this.currentIndex = 0;\r\n      this.domainLevel = Math.min(this.domainLevel + 1, 2);\r\n    }\r\n\r\n    // Use correct URL patterns based on research (November 2025)\r\n    let baseUrl;\r\n\r\n    // Different URL patterns for different domains\r\n    if (domain.includes('vidsrc.to') || domain.includes('vidsrc.cc') || domain.includes('vidsrc.org') || domain.includes('vidsrc.me')) {\r\n      // These domains use the /embed/movie/ID pattern\r\n      baseUrl = type === 'movie'\r\n        ? `${domain}/movie/${id}`\r\n        : `${domain}/tv/${id}/${season}/${episode}`;\r\n    } else if (domain.includes('embedsu.com') || domain.includes('2embed.cc') || domain.includes('autoembed.cc')) {\r\n      // These domains use direct embed pattern\r\n      baseUrl = type === 'movie'\r\n        ? `${domain}/${id}`\r\n        : `${domain}/${id}/${season}/${episode}`;\r\n    } else if (domain.includes('embed.su')) {\r\n      // embed.su uses /embed/movie/ID pattern\r\n      baseUrl = type === 'movie'\r\n        ? `${domain}/movie/${id}`\r\n        : `${domain}/tv/${id}/${season}/${episode}`;\r\n    } else if (domain.includes('player.smashystream.com')) {\r\n      // smashystream uses /movie/ID pattern\r\n      baseUrl = type === 'movie'\r\n        ? `${domain}/${id}`\r\n        : `${domain}/${id}/${season}/${episode}`;\r\n    } else if (domain.includes('multiembed.mov')) {\r\n      // multiembed uses directstream.php pattern\r\n      baseUrl = type === 'movie'\r\n        ? `${domain}=${id}`\r\n        : `${domain}=${id}&season=${season}&episode=${episode}`;\r\n    } else if (domain.includes('vidplay.online')) {\r\n      // vidplay uses /embed/ID pattern\r\n      baseUrl = type === 'movie'\r\n        ? `${domain}/${id}`\r\n        : `${domain}/${id}?s=${season}&e=${episode}`;\r\n    } else if (domain.includes('embedsoap.com') || domain.includes('www.embedsoap.com')) {\r\n      // embedsoap uses /embed/movie/?id=ID pattern\r\n      baseUrl = type === 'movie'\r\n        ? `${domain}?id=${id}`\r\n        : `${domain}?id=${id}&s=${season}&e=${episode}`;\r\n    } else if (domain.includes('solarmovie.pe')) {\r\n      // solarmovie uses /embed/ID pattern\r\n      baseUrl = type === 'movie'\r\n        ? `${domain}/${id}`\r\n        : `${domain}/${id}?s=${season}&e=${episode}`;\r\n    } else if (domain.includes('flixhq.to')) {\r\n      // flixhq uses /embed/ID pattern\r\n      baseUrl = type === 'movie'\r\n        ? `${domain}/${id}`\r\n        : `${domain}/${id}?s=${season}&e=${episode}`;\r\n    } else if (domain.includes('player.smashystream.com')) {\r\n      // smashystream uses /movie/ID pattern\r\n      baseUrl = type === 'movie'\r\n        ? `${domain}/${id}`\r\n        : `${domain}/${id}/${season}/${episode}`;\r\n    } else {\r\n      // Default pattern for other domains\r\n      baseUrl = type === 'movie'\r\n        ? `${domain}/movie/${id}`\r\n        : `${domain}/tv/${id}/${season}/${episode}`;\r\n    }\r\n\r\n    return quality !== 'auto' ? `${baseUrl}?q=${quality}` : baseUrl;\r\n  }\r\n\r\n  recordFailure() {\r\n    this.retryCount++;\r\n    if (this.retryCount >= this.maxRetries) {\r\n      this.reset();\r\n      throw new Error('All streaming sources failed');\r\n    }\r\n  }\r\n\r\n  recordSuccess() {\r\n    this.retryCount = 0;\r\n    this.currentIndex = 0;\r\n    this.domainLevel = 0;\r\n  }\r\n\r\n  reset() {\r\n    this.currentIndex = 0;\r\n    this.retryCount = 0;\r\n    this.domainLevel = 0;\r\n  }\r\n\r\n  getCurrentDomain() {\r\n    const domains = this.getDomainsForCurrentLevel();\r\n    return domains[this.currentIndex % domains.length];\r\n  }\r\n}\r\n\r\n// Error Recovery Manager Class\r\nclass ErrorRecoveryManager {\r\n  constructor(fallbackManager) {\r\n    this.fallbackManager = fallbackManager;\r\n    this.recoveryStrategies = new Map();\r\n    this.initializeStrategies();\r\n  }\r\n\r\n  initializeStrategies() {\r\n    this.recoveryStrategies.set(StreamErrorTypes.NETWORK_ERROR, this.handleNetworkError.bind(this));\r\n    this.recoveryStrategies.set(StreamErrorTypes.TIMEOUT_ERROR, this.handleTimeoutError.bind(this));\r\n    this.recoveryStrategies.set(StreamErrorTypes.PLAYER_ERROR, this.handlePlayerError.bind(this));\r\n    this.recoveryStrategies.set(StreamErrorTypes.CONTENT_NOT_FOUND, this.handleContentNotFound.bind(this));\r\n    this.recoveryStrategies.set(StreamErrorTypes.QUALITY_UNAVAILABLE, this.handleQualityError.bind(this));\r\n  }\r\n\r\n  async recover(error, context) {\r\n    const strategy = this.recoveryStrategies.get(error.type);\r\n    if (strategy) {\r\n      return await strategy(error, context);\r\n    }\r\n    throw error;\r\n  }\r\n\r\n  async handleNetworkError(error, context) {\r\n    // Wait with exponential backoff\r\n    const delay = this.calculateBackoffDelay(context.retryCount);\r\n    await this.delay(delay);\r\n\r\n    return this.fallbackManager.getNextUrl(\r\n      context.type,\r\n      context.id,\r\n      context.season,\r\n      context.episode,\r\n      context.quality\r\n    );\r\n  }\r\n\r\n  async handleTimeoutError(error, context) {\r\n    // Reduce quality and retry\r\n    const newQuality = this.reduceQuality(context.quality);\r\n    return this.fallbackManager.getNextUrl(\r\n      context.type,\r\n      context.id,\r\n      context.season,\r\n      context.episode,\r\n      newQuality\r\n    );\r\n  }\r\n\r\n  async handlePlayerError(error, context) {\r\n    // Try different domain\r\n    return this.fallbackManager.getNextUrl(\r\n      context.type,\r\n      context.id,\r\n      context.season,\r\n      context.episode,\r\n      context.quality\r\n    );\r\n  }\r\n\r\n  async handleContentNotFound(error, context) {\r\n    // Try alternative sources\r\n    this.fallbackManager.domainLevel = 2; // Use alternative domains\r\n    return this.fallbackManager.getNextUrl(\r\n      context.type,\r\n      context.id,\r\n      context.season,\r\n      context.episode,\r\n      context.quality\r\n    );\r\n  }\r\n\r\n  async handleQualityError(error, context) {\r\n    // Reduce quality and retry\r\n    const newQuality = this.reduceQuality(context.quality);\r\n    return this.fallbackManager.getNextUrl(\r\n      context.type,\r\n      context.id,\r\n      context.season,\r\n      context.episode,\r\n      newQuality\r\n    );\r\n  }\r\n\r\n  calculateBackoffDelay(retryCount) {\r\n    // Enhanced exponential backoff with jitter (November 2025)\r\n    const baseDelay = 1000 * Math.pow(2, retryCount);\r\n    const jitter = Math.random() * 1000; // Add random jitter up to 1 second\r\n    return Math.min(baseDelay + jitter, 15000); // Max 15 seconds\r\n  }\r\n\r\n  delay(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  }\r\n\r\n  // Enhanced quality reduction strategy\r\n  reduceQuality(currentQuality) {\r\n    const qualityHierarchy = [QualityOptions.Q4K, QualityOptions.Q1080P, QualityOptions.Q720P, QualityOptions.Q480P, QualityOptions.Q360P];\r\n    const currentIndex = qualityHierarchy.indexOf(currentQuality);\r\n\r\n    if (currentIndex < qualityHierarchy.length - 1) {\r\n      return qualityHierarchy[currentIndex + 1];\r\n    }\r\n\r\n    return QualityOptions.Q360P;\r\n  }\r\n\r\n  reduceQuality(currentQuality) {\r\n    const qualityHierarchy = [QualityOptions.Q4K, QualityOptions.Q1080P, QualityOptions.Q720P, QualityOptions.Q480P, QualityOptions.Q360P];\r\n    const currentIndex = qualityHierarchy.indexOf(currentQuality);\r\n\r\n    if (currentIndex < qualityHierarchy.length - 1) {\r\n      return qualityHierarchy[currentIndex + 1];\r\n    }\r\n\r\n    return QualityOptions.Q360P;\r\n  }\r\n}\r\n\r\n// Performance Monitor Class\r\nclass PerformanceMonitor {\r\n  constructor() {\r\n    this.metrics = {\r\n      streamLoadTime: [],\r\n      bufferingEvents: [],\r\n      qualitySwitches: [],\r\n      errorRates: [],\r\n      userEngagement: []\r\n    };\r\n    this.startTime = null;\r\n  }\r\n\r\n  startTracking() {\r\n    this.startTime = Date.now();\r\n  }\r\n\r\n  trackStreamLoadTime(endTime) {\r\n    if (!this.startTime) return;\r\n\r\n    const loadTime = endTime - this.startTime;\r\n    this.metrics.streamLoadTime.push(loadTime);\r\n\r\n    if (loadTime > 10000) { // 10 seconds\r\n      console.warn('Slow stream loading detected:', loadTime);\r\n    }\r\n  }\r\n\r\n  trackBufferingEvent(duration) {\r\n    this.metrics.bufferingEvents.push({\r\n      timestamp: Date.now(),\r\n      duration\r\n    });\r\n  }\r\n\r\n  trackQualitySwitch(from, to) {\r\n    this.metrics.qualitySwitches.push({\r\n      timestamp: Date.now(),\r\n      from,\r\n      to\r\n    });\r\n  }\r\n\r\n  trackError(error) {\r\n    this.metrics.errorRates.push({\r\n      timestamp: Date.now(),\r\n      error: error.message\r\n    });\r\n  }\r\n\r\n  generateReport() {\r\n    const loadTimes = this.metrics.streamLoadTime;\r\n    return {\r\n      averageLoadTime: loadTimes.length > 0 ? loadTimes.reduce((a, b) => a + b, 0) / loadTimes.length : 0,\r\n      bufferingFrequency: this.metrics.bufferingEvents.length,\r\n      qualitySwitchCount: this.metrics.qualitySwitches.length,\r\n      errorCount: this.metrics.errorRates.length,\r\n      successRate: this.calculateSuccessRate()\r\n    };\r\n  }\r\n\r\n  calculateSuccessRate() {\r\n    const totalAttempts = this.metrics.streamLoadTime.length + this.metrics.errorRates.length;\r\n    return totalAttempts > 0 ? (this.metrics.streamLoadTime.length / totalAttempts) * 100 : 0;\r\n  }\r\n}\r\n\r\n// Global instances\r\nconst fallbackManager = new FallbackManager();\r\nconst errorRecoveryManager = new ErrorRecoveryManager(fallbackManager);\r\nconst performanceMonitor = new PerformanceMonitor();\r\n\r\nexport const vidsrcApi = {\r\n  // Enhanced streaming URL generation with fallback support\r\n  getMovieStream: (tmdbId, options = {}) => {\r\n    const { quality = 'auto', useFallback = true } = options;\r\n\r\n    try {\r\n      const url = useFallback\r\n        ? fallbackManager.getNextUrl('movie', tmdbId, null, null, quality)\r\n        : `${VIDSRC_DOMAINS.primary}/movie/${tmdbId}${quality !== 'auto' ? `?q=${quality}` : ''}`;\r\n\r\n      return {\r\n        url,\r\n        type: 'movie',\r\n        provider: 'vidsrc',\r\n        embeddable: true,\r\n        quality,\r\n        fallbackSupported: useFallback\r\n      };\r\n    } catch (error) {\r\n      return this.getErrorStream('movie', tmdbId, error);\r\n    }\r\n  },\r\n\r\n  // Enhanced TV streaming with fallback support\r\n  getTVStream: (tmdbId, season = 1, episode = 1, options = {}) => {\r\n    const { quality = 'auto', useFallback = true } = options;\r\n\r\n    try {\r\n      const url = useFallback\r\n        ? fallbackManager.getNextUrl('tv', tmdbId, season, episode, quality)\r\n        : `${VIDSRC_DOMAINS.primary}/tv/${tmdbId}/${season}/${episode}${quality !== 'auto' ? `?q=${quality}` : ''}`;\r\n\r\n      return {\r\n        url,\r\n        type: 'tv',\r\n        provider: 'vidsrc',\r\n        embeddable: true,\r\n        season,\r\n        episode,\r\n        quality,\r\n        fallbackSupported: useFallback\r\n      };\r\n    } catch (error) {\r\n      return this.getErrorStream('tv', tmdbId, error, season, episode);\r\n    }\r\n  },\r\n\r\n  // Get error stream for failed requests\r\n  getErrorStream: (type, id, error, season = null, episode = null) => {\r\n    return {\r\n      url: '',\r\n      type,\r\n      provider: 'error',\r\n      embeddable: false,\r\n      error: error.message,\r\n      season,\r\n      episode\r\n    };\r\n  },\r\n\r\n  // Try alternative URL patterns for better compatibility (November 2025)\r\n  tryAlternativeUrls: (tmdbId, type, season = null, episode = null) => {\r\n    const alternatives = [];\r\n\r\n    // Try current working VidSrc domains from research\r\n    const domains = [\r\n      'https://vidsrc.to/embed',\r\n      'https://vidsrc.cc/embed',\r\n      'https://vidsrc.org/embed',\r\n      'https://vidsrc.me/embed',\r\n      'https://vidsrc.net/embed',\r\n      'https://vidsrc.xyz/embed',\r\n      'https://vidsrc.io/embed',\r\n      'https://vidsrc.vc/embed',\r\n      'https://vidsrc.bz/embed',\r\n      'https://vidsrc.gd/embed'\r\n    ];\r\n\r\n    domains.forEach(domain => {\r\n      if (type === 'movie') {\r\n        alternatives.push(`${domain}/movie/${tmdbId}`);\r\n      } else {\r\n        alternatives.push(`${domain}/tv/${tmdbId}/${season || 1}/${episode || 1}`);\r\n      }\r\n    });\r\n\r\n    // Add alternative streaming sources\r\n    const altSources = [\r\n      `https://embedsu.com/embed/${tmdbId}`,\r\n      `https://www.2embed.cc/embed/${tmdbId}`,\r\n      `https://embed.su/embed/movie/${tmdbId}`,\r\n      `https://autoembed.cc/embed/${tmdbId}`,\r\n      `https://vidsrcsu.com/embed/${tmdbId}`,\r\n      `https://vidsrc.pk/embed/${tmdbId}`,\r\n      `https://www.embedsoap.com/embed/movie/?id=${tmdbId}`,\r\n      `https://player.smashystream.com/movie/${tmdbId}`,\r\n      `https://multiembed.mov/directstream.php?video_id=${tmdbId}`,\r\n      `https://vidplay.online/embed/${tmdbId}`,\r\n      `https://www.solarmovie.pe/embed/${tmdbId}`,\r\n      `https://flixhq.to/embed/${tmdbId}`\r\n    ];\r\n\r\n    alternatives.push(...altSources);\r\n\r\n    return alternatives;\r\n  },\r\n\r\n  // Enhanced multiple streaming sources with quality options\r\n  getMovieSources: (tmdbId, options = {}) => {\r\n    const { includeAlternatives = true, quality = 'auto' } = options;\r\n    const sources = [];\r\n\r\n    // Primary VidSrc sources with different qualities\r\n    const qualities = [QualityOptions.Q4K, QualityOptions.Q1080P, QualityOptions.Q720P, QualityOptions.Q480P];\r\n\r\n    qualities.forEach((q, index) => {\r\n      sources.push({\r\n        id: `vidsrc-${q}`,\r\n        name: `VidSrc ${q.toUpperCase()}`,\r\n        url: fallbackManager.getNextUrl('movie', tmdbId, null, null, q),\r\n        embeddable: true,\r\n        quality: q,\r\n        provider: 'vidsrc',\r\n        primary: index === 0\r\n      });\r\n    });\r\n\r\n    // Backup domains for primary quality\r\n    if (includeAlternatives) {\r\n      VIDSRC_DOMAINS.fallbacks.forEach((domain, index) => {\r\n        sources.push({\r\n          id: `vidsrc-backup-${index}`,\r\n          name: `VidSrc Backup ${index + 1}`,\r\n          url: `${domain}/movie/${tmdbId}${quality !== 'auto' ? `?q=${quality}` : ''}`,\r\n          embeddable: true,\r\n          quality: quality,\r\n          provider: 'vidsrc',\r\n          backup: true\r\n        });\r\n      });\r\n\r\n      // Alternative sources - using the fallback manager for correct URL patterns\r\n      VIDSRC_DOMAINS.alternative.forEach((domain, index) => {\r\n        const sourceId = `alt-${index}`;\r\n        let sourceName = `Alternative ${index + 1}`;\r\n        let provider = `alternative-${index}`;\r\n\r\n        // Set meaningful names for known sources\r\n        if (domain.includes('2embed.cc')) {\r\n          sourceName = '2Embed';\r\n          provider = '2embed';\r\n        } else if (domain.includes('embedsu.com')) {\r\n          sourceName = 'EmbedSu';\r\n          provider = 'embedsu';\r\n        } else if (domain.includes('autoembed.cc')) {\r\n          sourceName = 'AutoEmbed';\r\n          provider = 'autoembed';\r\n        } else if (domain.includes('embed.su')) {\r\n          sourceName = 'Embed.su';\r\n          provider = 'embedsu';\r\n        } else if (domain.includes('smashystream.com')) {\r\n          sourceName = 'SmashyStream';\r\n          provider = 'smashystream';\r\n        } else if (domain.includes('multiembed.mov')) {\r\n          sourceName = 'MultiEmbed';\r\n          provider = 'multiembed';\r\n        } else if (domain.includes('vidplay.online')) {\r\n          sourceName = 'VidPlay';\r\n          provider = 'vidplay';\r\n        } else if (domain.includes('embedsoap.com')) {\r\n          sourceName = 'EmbedSoap';\r\n          provider = 'embedsoap';\r\n        } else if (domain.includes('solarmovie.pe')) {\r\n          sourceName = 'SolarMovie';\r\n          provider = 'solarmovie';\r\n        } else if (domain.includes('flixhq.to')) {\r\n          sourceName = 'FlixHQ';\r\n          provider = 'flixhq';\r\n        } else if (domain.includes('multiembed.mov')) {\r\n          sourceName = 'MultiEmbed';\r\n          provider = 'multiembed';\r\n        } else if (domain.includes('player.smashystream.com')) {\r\n          sourceName = 'SmashyStream';\r\n          provider = 'smashystream';\r\n        }\r\n\r\n        sources.push({\r\n          id: sourceId,\r\n          name: sourceName,\r\n          url: fallbackManager.getNextUrl('movie', tmdbId, null, null, quality),\r\n          embeddable: true,\r\n          quality: 'HD',\r\n          provider: provider,\r\n          alternative: true\r\n        });\r\n      });\r\n    }\r\n\r\n    return sources;\r\n  },\r\n\r\n  // Enhanced TV sources with quality options\r\n  getTVSources: (tmdbId, season = 1, episode = 1, options = {}) => {\r\n    const { includeAlternatives = true, quality = 'auto' } = options;\r\n    const sources = [];\r\n\r\n    // Primary VidSrc sources with different qualities\r\n    const qualities = [QualityOptions.Q1080P, QualityOptions.Q720P, QualityOptions.Q480P];\r\n\r\n    qualities.forEach((q, index) => {\r\n      sources.push({\r\n        id: `vidsrc-${q}`,\r\n        name: `VidSrc ${q.toUpperCase()}`,\r\n        url: fallbackManager.getNextUrl('tv', tmdbId, season, episode, q),\r\n        embeddable: true,\r\n        quality: q,\r\n        provider: 'vidsrc',\r\n        season,\r\n        episode,\r\n        primary: index === 0\r\n      });\r\n    });\r\n\r\n    // Backup domains for primary quality\r\n    if (includeAlternatives) {\r\n      VIDSRC_DOMAINS.fallbacks.forEach((domain, index) => {\r\n        sources.push({\r\n          id: `vidsrc-backup-${index}`,\r\n          name: `VidSrc Backup ${index + 1}`,\r\n          url: `${domain}/tv/${tmdbId}/${season}/${episode}${quality !== 'auto' ? `?q=${quality}` : ''}`,\r\n          embeddable: true,\r\n          quality: quality,\r\n          provider: 'vidsrc',\r\n          season,\r\n          episode,\r\n          backup: true\r\n        });\r\n      });\r\n    }\r\n\r\n    return sources;\r\n  },\r\n\r\n  // Check if streaming is available for a movie\r\n  checkAvailability: async (tmdbId, type = 'movie') => {\r\n    try {\r\n      // VidSrc doesn't have a formal availability check API\r\n      // We assume content is available if it has a valid TMDB ID\r\n      return {\r\n        available: true,\r\n        provider: 'vidsrc',\r\n        embeddable: true,\r\n        message: 'Streaming available via VidSrc'\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        available: false,\r\n        provider: 'vidsrc',\r\n        embeddable: false,\r\n        message: 'Streaming temporarily unavailable'\r\n      };\r\n    }\r\n  },\r\n\r\n  // Get streaming quality information\r\n  getQualityInfo: () => {\r\n    return {\r\n      default: '1080p',\r\n      available: ['720p', '1080p', '4K'],\r\n      note: 'Quality automatically adjusts based on connection speed'\r\n    };\r\n  },\r\n\r\n  // Get supported regions\r\n  getSupportedRegions: () => {\r\n    return {\r\n      regions: ['IN', 'US', 'UK', 'CA', 'AU', 'DE', 'FR', 'JP', 'KR', 'BR', 'MX', 'ES', 'IT', 'NL', 'SE', 'NO', 'DK', 'FI', 'PL', 'RU', 'CN', 'HK', 'TW', 'SG', 'MY', 'TH', 'VN', 'PH', 'ID', 'AE', 'SA', 'EG', 'ZA', 'NG', 'KE', 'MA', 'TN', 'DZ', 'AR', 'CL', 'CO', 'PE', 'VE', 'EC', 'UY', 'PY', 'BO', 'GT', 'CR', 'PA', 'DO', 'JM', 'TT', 'BB', 'LC', 'VC', 'GD', 'AG', 'DM', 'KN', 'MS', 'VG', 'AI', 'BM', 'KY', 'TC', 'FK', 'GS', 'SH', 'IO', 'AC', 'TA', 'PN', 'WF', 'PF', 'NC', 'VU', 'FJ', 'PG', 'SB', 'KI', 'NR', 'TV', 'TO', 'WS', 'CK', 'NU', 'TK', 'AS', 'GU', 'MP', 'FM', 'MH', 'PW', 'UM', 'VI', 'PR'],\r\n      note: 'VidSrc works globally with no regional restrictions'\r\n    };\r\n  },\r\n\r\n  // Enhanced error handling with recovery\r\n  handleStreamError: async (error, context) => {\r\n    performanceMonitor.trackError(error);\r\n\r\n    try {\r\n      const recoveredUrl = await errorRecoveryManager.recover(error, context);\r\n      fallbackManager.recordSuccess();\r\n      return {\r\n        success: true,\r\n        url: recoveredUrl,\r\n        recovered: true\r\n      };\r\n    } catch (recoveryError) {\r\n      fallbackManager.recordFailure();\r\n      return {\r\n        success: false,\r\n        error: recoveryError.message,\r\n        fallbackExhausted: true\r\n      };\r\n    }\r\n  },\r\n\r\n  // Get available quality options\r\n  getQualityOptions: (contentType = 'movie') => {\r\n    const baseQualities = [QualityOptions.Q1080P, QualityOptions.Q720P, QualityOptions.Q480P];\r\n\r\n    if (contentType === 'movie') {\r\n      baseQualities.unshift(QualityOptions.Q4K);\r\n    }\r\n\r\n    return baseQualities;\r\n  },\r\n\r\n  // Test stream availability with enhanced error handling (November 2025)\r\n  testStream: async (url, timeout = 8000) => {\r\n    const startTime = Date.now();\r\n\r\n    // Create a timeout promise with AbortController for better control\r\n    const controller = new AbortController();\r\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\r\n\r\n    try {\r\n      // Try HEAD request first (more efficient)\r\n      const response = await fetch(url, {\r\n        method: 'HEAD',\r\n        signal: controller.signal,\r\n        headers: {\r\n          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\r\n        }\r\n      });\r\n\r\n      clearTimeout(timeoutId);\r\n      const loadTime = Date.now() - startTime;\r\n      performanceMonitor.trackStreamLoadTime(Date.now());\r\n\r\n      // Check if response is successful and content exists\r\n      if (response.ok && response.status < 400) {\r\n        return {\r\n          available: true,\r\n          loadTime,\r\n          url,\r\n          responseTime: loadTime,\r\n          method: 'HEAD',\r\n          status: response.status\r\n        };\r\n      } else {\r\n        return {\r\n          available: false,\r\n          loadTime,\r\n          error: `HTTP ${response.status}: ${response.statusText}`,\r\n          errorType: response.status === 404 ? StreamErrorTypes.CONTENT_NOT_FOUND : StreamErrorTypes.PLAYER_ERROR,\r\n          url,\r\n          responseTime: loadTime,\r\n          method: 'HEAD',\r\n          status: response.status,\r\n          retryable: response.status !== 404\r\n        };\r\n      }\r\n    } catch (headError) {\r\n      try {\r\n        // If HEAD fails, try GET request to actually check content\r\n        const getResponse = await fetch(url, {\r\n          method: 'GET',\r\n          signal: controller.signal,\r\n          headers: {\r\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\r\n          }\r\n        });\r\n\r\n        clearTimeout(timeoutId);\r\n        const loadTime = Date.now() - startTime;\r\n        performanceMonitor.trackStreamLoadTime(Date.now());\r\n\r\n        // Check if response is successful\r\n        if (getResponse.ok && getResponse.status < 400) {\r\n          // Try to read response text to verify it's not an error page\r\n          const responseText = await getResponse.text();\r\n          const contentLength = responseText.length;\r\n\r\n          // Basic checks for video availability\r\n          const hasVideoContent = contentLength > 1000; // Minimum content length\r\n          const isErrorPage = responseText.includes('not found') ||\r\n                             responseText.includes('video not available') ||\r\n                             responseText.includes('error') ||\r\n                             responseText.includes('404') ||\r\n                             responseText.includes('Video not found');\r\n\r\n          if (hasVideoContent && !isErrorPage) {\r\n            return {\r\n              available: true,\r\n              loadTime,\r\n              url,\r\n              responseTime: loadTime,\r\n              method: 'GET',\r\n              status: getResponse.status,\r\n              contentLength\r\n            };\r\n          } else {\r\n            return {\r\n              available: false,\r\n              loadTime,\r\n              error: isErrorPage ? 'Video not found on server' : 'Insufficient content or error page detected',\r\n              errorType: StreamErrorTypes.CONTENT_NOT_FOUND,\r\n              url,\r\n              responseTime: loadTime,\r\n              method: 'GET',\r\n              status: getResponse.status,\r\n              contentLength,\r\n              retryable: false\r\n            };\r\n          }\r\n        } else {\r\n          return {\r\n            available: false,\r\n            loadTime,\r\n            error: `HTTP ${getResponse.status}: ${getResponse.statusText}`,\r\n            errorType: getResponse.status === 404 ? StreamErrorTypes.CONTENT_NOT_FOUND : StreamErrorTypes.PLAYER_ERROR,\r\n            url,\r\n            responseTime: loadTime,\r\n            method: 'GET',\r\n            status: getResponse.status,\r\n            retryable: getResponse.status !== 404\r\n          };\r\n        }\r\n      } catch (getError) {\r\n        clearTimeout(timeoutId);\r\n        const loadTime = Date.now() - startTime;\r\n        performanceMonitor.trackStreamLoadTime(Date.now());\r\n\r\n        // Enhanced error classification based on November 2025 standards\r\n        let errorType = StreamErrorTypes.NETWORK_ERROR;\r\n        let errorMessage = getError.message;\r\n\r\n        if (getError.name === 'AbortError' || getError.message.includes('timeout') || getError.message.includes('aborted')) {\r\n          errorType = StreamErrorTypes.TIMEOUT_ERROR;\r\n          errorMessage = 'Request timeout - server took too long to respond';\r\n        } else if (getError.message.includes('404') || getError.message.includes('Not Found')) {\r\n          errorType = StreamErrorTypes.CONTENT_NOT_FOUND;\r\n          errorMessage = 'Video not found on this server';\r\n        } else if (getError.message.includes('403') || getError.message.includes('Forbidden')) {\r\n          errorType = StreamErrorTypes.GEO_BLOCKED;\r\n          errorMessage = 'Content blocked in your region';\r\n        } else if (getError.message.includes('NetworkError') || getError.message.includes('Failed to fetch')) {\r\n          errorType = StreamErrorTypes.NETWORK_ERROR;\r\n          errorMessage = 'Network connection failed';\r\n        }\r\n\r\n        return {\r\n          available: false,\r\n          loadTime,\r\n          error: errorMessage,\r\n          errorType,\r\n          url,\r\n          responseTime: loadTime,\r\n          retryable: errorType !== StreamErrorTypes.CONTENT_NOT_FOUND\r\n        };\r\n      }\r\n    }\r\n  },\r\n\r\n  // Get performance metrics\r\n  getPerformanceReport: () => {\r\n    return performanceMonitor.generateReport();\r\n  },\r\n\r\n  // Test multiple sources and return the first working one\r\n  testMultipleSources: async (sources, options = {}) => {\r\n    const { timeout = 8000, maxConcurrent = 3 } = options;\r\n    const workingSources = [];\r\n    const failedSources = [];\r\n\r\n    console.log(`🔍 [DEBUG] Starting comprehensive source testing`);\r\n    console.log(`🔍 [DEBUG] Total sources: ${sources.length}, Timeout: ${timeout}ms, Max concurrent: ${maxConcurrent}`);\r\n\r\n    // Test sources in batches to avoid overwhelming servers\r\n    for (let i = 0; i < sources.length; i += maxConcurrent) {\r\n      const batch = sources.slice(i, i + maxConcurrent);\r\n      console.log(`🔍 [DEBUG] Testing batch ${Math.floor(i/maxConcurrent) + 1}/${Math.ceil(sources.length/maxConcurrent)}`);\r\n\r\n      const batchPromises = batch.map(async (source) => {\r\n        const startTime = Date.now();\r\n        try {\r\n          console.log(`🔍 [DEBUG] Testing: ${source.name || source.id} (${source.provider})`);\r\n          const result = await vidsrcApi.testStream(source.url, timeout);\r\n          const testTime = Date.now() - startTime;\r\n\r\n          console.log(`🔍 [DEBUG] Result: ${result.available ? '✅' : '❌'} ${source.name || source.id} (${testTime}ms)`);\r\n\r\n          return { source, result };\r\n        } catch (error) {\r\n          const testTime = Date.now() - startTime;\r\n          console.log(`🔍 [DEBUG] Error: ❌ ${source.name || source.id} - ${error.message} (${testTime}ms)`);\r\n          return {\r\n            source,\r\n            result: {\r\n              available: false,\r\n              error: error.message,\r\n              errorType: 'TEST_ERROR'\r\n            }\r\n          };\r\n        }\r\n      });\r\n\r\n      const batchResults = await Promise.all(batchPromises);\r\n\r\n      batchResults.forEach(({ source, result }) => {\r\n        if (result.available) {\r\n          workingSources.push({ ...source, testResult: result });\r\n          console.log(`✅ [DEBUG] Working source found: ${source.name || source.id}`);\r\n        } else {\r\n          failedSources.push({ ...source, testResult: result });\r\n          console.log(`❌ [DEBUG] Failed source: ${source.name || source.id} - ${result.error || 'Unknown error'}`);\r\n        }\r\n      });\r\n    }\r\n\r\n    const successRate = sources.length > 0 ? (workingSources.length / sources.length) * 100 : 0;\r\n    console.log(`📊 [DEBUG] Testing complete: ${workingSources.length}/${sources.length} working (${successRate.toFixed(1)}%)`);\r\n\r\n    return {\r\n      working: workingSources,\r\n      failed: failedSources,\r\n      total: sources.length,\r\n      successRate\r\n    };\r\n  },\r\n\r\n  // Enhanced method to find the first working source quickly\r\n  findFirstWorkingSource: async (sources, options = {}) => {\r\n    const { timeout = 5000, maxConcurrent = 5 } = options;\r\n\r\n    console.log(`🔍 [DEBUG] Starting source testing for ${sources.length} sources`);\r\n    console.log(`🔍 [DEBUG] Timeout: ${timeout}ms, Max concurrent: ${maxConcurrent}`);\r\n\r\n    // Test sources in parallel batches\r\n    for (let i = 0; i < sources.length; i += maxConcurrent) {\r\n      const batch = sources.slice(i, i + maxConcurrent);\r\n      console.log(`🔍 [DEBUG] Testing batch ${Math.floor(i/maxConcurrent) + 1}: ${batch.map(s => s.name || s.id).join(', ')}`);\r\n\r\n      const batchPromises = batch.map(async (source) => {\r\n        const startTime = Date.now();\r\n        try {\r\n          console.log(`🔍 [DEBUG] Testing source: ${source.name || source.id} - ${source.url}`);\r\n          const result = await vidsrcApi.testStream(source.url, timeout);\r\n\r\n          const testTime = Date.now() - startTime;\r\n          console.log(`🔍 [DEBUG] Source ${source.name || source.id}: ${result.available ? '✅ AVAILABLE' : '❌ FAILED'} (${testTime}ms)`);\r\n\r\n          if (!result.available) {\r\n            console.log(`🔍 [DEBUG] Source ${source.name || source.id} failed: ${result.error || 'Unknown error'}`);\r\n          }\r\n\r\n          if (result.available) {\r\n            return { source, result, success: true };\r\n          }\r\n          return { source, result, success: false };\r\n        } catch (error) {\r\n          const testTime = Date.now() - startTime;\r\n          console.log(`🔍 [DEBUG] Source ${source.name || source.id} error: ${error.message} (${testTime}ms)`);\r\n          return { source, result: { available: false, error: error.message }, success: false };\r\n        }\r\n      });\r\n\r\n      const batchResults = await Promise.all(batchPromises);\r\n\r\n      // Return the first working source found\r\n      const workingSource = batchResults.find(result => result.success);\r\n      if (workingSource) {\r\n        console.log(`🎉 [DEBUG] Found working source: ${workingSource.source.name || workingSource.source.id}`);\r\n        console.log(`🎉 [DEBUG] URL: ${workingSource.source.url}`);\r\n        console.log(`🎉 [DEBUG] Provider: ${workingSource.source.provider}`);\r\n        return workingSource;\r\n      }\r\n    }\r\n\r\n    console.log(`❌ [DEBUG] No working sources found after testing all ${sources.length} sources`);\r\n    return null; // No working sources found\r\n  },\r\n\r\n  // Get best available source with automatic testing\r\n  getBestAvailableSource: async (tmdbId, type, season = null, episode = null, options = {}) => {\r\n    const { testSources = true, quality = 'auto' } = options;\r\n\r\n    // Get all available sources\r\n    const sources = type === 'movie'\r\n      ? vidsrcApi.getMovieSources(tmdbId, { includeAlternatives: true, quality })\r\n      : vidsrcApi.getTVSources(tmdbId, season, episode, { includeAlternatives: true, quality });\r\n\r\n    if (!testSources) {\r\n      return sources[0]; // Return first source without testing\r\n    }\r\n\r\n    // Test sources and return the first working one\r\n    const testResult = await vidsrcApi.testMultipleSources(sources);\r\n\r\n    if (testResult.working.length > 0) {\r\n      return testResult.working[0];\r\n    }\r\n\r\n    // If no sources work, return the primary source with error info\r\n    return {\r\n      ...sources[0],\r\n      testResult: {\r\n        available: false,\r\n        error: 'No working sources found',\r\n        errorType: 'ALL_SOURCES_FAILED'\r\n      }\r\n    };\r\n  },\r\n\r\n  // Reset fallback manager\r\n  resetFallbackManager: () => {\r\n    fallbackManager.reset();\r\n    performanceMonitor.startTracking();\r\n  },\r\n\r\n  // Get current fallback status\r\n  getFallbackStatus: () => {\r\n    return {\r\n      currentDomain: fallbackManager.getCurrentDomain(),\r\n      retryCount: fallbackManager.retryCount,\r\n      domainLevel: fallbackManager.domainLevel,\r\n      maxRetries: fallbackManager.maxRetries\r\n    };\r\n  },\r\n\r\n  // Manual source verification as backup when automatic testing fails\r\n  verifySourceManually: async (url, timeout = 10000) => {\r\n    console.log(`🔍 [Manual] Starting manual verification for: ${url}`);\r\n\r\n    return new Promise((resolve) => {\r\n      const iframe = document.createElement('iframe');\r\n      iframe.src = url;\r\n      iframe.style.display = 'none';\r\n      iframe.sandbox = 'allow-same-origin allow-scripts allow-presentation';\r\n\r\n      const startTime = Date.now();\r\n      let hasLoaded = false;\r\n      let hasError = false;\r\n\r\n      const cleanup = () => {\r\n        if (iframe.parentNode) {\r\n          iframe.parentNode.removeChild(iframe);\r\n        }\r\n        clearTimeout(timeoutId);\r\n      };\r\n\r\n      const timeoutId = setTimeout(() => {\r\n        if (!hasLoaded && !hasError) {\r\n          console.log(`⏱️ [Manual] Manual verification timeout for: ${url}`);\r\n          cleanup();\r\n          resolve({\r\n            available: false,\r\n            error: 'Manual verification timeout',\r\n            errorType: 'TIMEOUT_ERROR',\r\n            method: 'manual-iframe',\r\n            loadTime: Date.now() - startTime\r\n          });\r\n        }\r\n      }, timeout);\r\n\r\n      iframe.onload = () => {\r\n        hasLoaded = true;\r\n        const loadTime = Date.now() - startTime;\r\n        console.log(`✅ [Manual] Manual verification success for: ${url} (${loadTime}ms)`);\r\n\r\n        // Additional check: try to access iframe content\r\n        try {\r\n          const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\r\n          const hasVideoElement = iframeDoc.querySelector('video') !== null;\r\n          const hasPlayerContainer = iframeDoc.querySelector('.player, #player, [class*=\"player\"]') !== null;\r\n          const isErrorPage = iframeDoc.body && iframeDoc.body.textContent.includes('not found');\r\n\r\n          if (isErrorPage) {\r\n            cleanup();\r\n            resolve({\r\n              available: false,\r\n              error: 'Video not found (detected error page)',\r\n              errorType: 'CONTENT_NOT_FOUND',\r\n              method: 'manual-iframe',\r\n              loadTime,\r\n              hasVideoElement,\r\n              hasPlayerContainer\r\n            });\r\n          } else if (hasVideoElement || hasPlayerContainer) {\r\n            cleanup();\r\n            resolve({\r\n              available: true,\r\n              loadTime,\r\n              method: 'manual-iframe',\r\n              hasVideoElement,\r\n              hasPlayerContainer\r\n            });\r\n          } else {\r\n            // Give it a bit more time to load video content\r\n            setTimeout(() => {\r\n              try {\r\n                const finalDoc = iframe.contentDocument || iframe.contentWindow.document;\r\n                const finalVideoElement = finalDoc.querySelector('video') !== null;\r\n                const finalPlayerContainer = finalDoc.querySelector('.player, #player, [class*=\"player\"]') !== null;\r\n\r\n                cleanup();\r\n                resolve({\r\n                  available: finalVideoElement || finalPlayerContainer,\r\n                  loadTime: Date.now() - startTime,\r\n                  method: 'manual-iframe',\r\n                  hasVideoElement: finalVideoElement,\r\n                  hasPlayerContainer: finalPlayerContainer\r\n                });\r\n              } catch (e) {\r\n                cleanup();\r\n                resolve({\r\n                  available: true, // Assume it's working if we can't check content\r\n                  loadTime: Date.now() - startTime,\r\n                  method: 'manual-iframe',\r\n                  note: 'Could not verify content due to CORS, assuming available'\r\n                });\r\n              }\r\n            }, 2000);\r\n          }\r\n        } catch (e) {\r\n          // CORS restriction - assume it's working if it loaded\r\n          cleanup();\r\n          resolve({\r\n            available: true,\r\n            loadTime,\r\n            method: 'manual-iframe',\r\n            note: 'Could not verify content due to CORS, assuming available'\r\n          });\r\n        }\r\n      };\r\n\r\n      iframe.onerror = () => {\r\n        hasError = true;\r\n        const loadTime = Date.now() - startTime;\r\n        console.log(`❌ [Manual] Manual verification failed for: ${url} (${loadTime}ms)`);\r\n        cleanup();\r\n        resolve({\r\n          available: false,\r\n          error: 'Failed to load iframe',\r\n          errorType: 'NETWORK_ERROR',\r\n          method: 'manual-iframe',\r\n          loadTime\r\n        });\r\n      };\r\n\r\n      document.body.appendChild(iframe);\r\n    });\r\n  },\r\n\r\n  // Create secure iframe embed\r\n  createSecureEmbed: (streamData, options = {}) => {\r\n    const {\r\n      width = '100%',\r\n      height = '500',\r\n      autoplay = false,\r\n      muted = false,\r\n      controls = true,\r\n      sandbox = 'allow-same-origin allow-scripts allow-presentation'\r\n    } = options;\r\n\r\n    const embedUrl = streamData.url;\r\n\r\n    return {\r\n      iframe: `<iframe\r\n        src=\"${embedUrl}\"\r\n        width=\"${width}\"\r\n        height=\"${height}\"\r\n        frameborder=\"0\"\r\n        allowfullscreen\r\n        ${autoplay ? 'autoplay' : ''}\r\n        ${muted ? 'muted' : ''}\r\n        ${controls ? '' : 'controls=\"false\"'}\r\n        sandbox=\"${sandbox}\"\r\n        allow=\"autoplay; encrypted-media; fullscreen; picture-in-picture\"\r\n        referrerpolicy=\"strict-origin-when-cross-origin\"\r\n        loading=\"lazy\"\r\n      ></iframe>`,\r\n      url: embedUrl,\r\n      type: streamData.type,\r\n      provider: streamData.provider,\r\n      security: {\r\n        sandbox,\r\n        referrerPolicy: 'strict-origin-when-cross-origin',\r\n        cspCompliant: true\r\n      }\r\n    };\r\n  }\r\n};\r\n\r\n// Helper function to create iframe embed code\r\nexport const createEmbedCode = (streamData, options = {}) => {\r\n  const {\r\n    width = '100%',\r\n    height = '500',\r\n    autoplay = false,\r\n    muted = false,\r\n    controls = true\r\n  } = options;\r\n\r\n  const embedUrl = streamData.url;\r\n\r\n  return {\r\n    iframe: `<iframe\r\n      src=\"${embedUrl}\"\r\n      width=\"${width}\"\r\n      height=\"${height}\"\r\n      frameborder=\"0\"\r\n      allowfullscreen\r\n      ${autoplay ? 'autoplay' : ''}\r\n      ${muted ? 'muted' : ''}\r\n      ${controls ? '' : 'controls=\"false\"'}\r\n      sandbox=\"allow-same-origin allow-scripts allow-presentation\"\r\n    ></iframe>`,\r\n    url: embedUrl,\r\n    type: streamData.type,\r\n    provider: streamData.provider\r\n  };\r\n};\r\n\r\n// Error handling for streaming\r\nexport const handleStreamError = (error, fallbackSources = []) => {\r\n  console.error('Streaming error:', error);\r\n\r\n  if (fallbackSources.length > 0) {\r\n    return {\r\n      success: false,\r\n      error: error.message,\r\n      fallback: fallbackSources[0],\r\n      hasFallback: true\r\n    };\r\n  }\r\n\r\n  return {\r\n    success: false,\r\n    error: error.message,\r\n    hasFallback: false\r\n  };\r\n};\r\n\r\nexport default vidsrcApi;\r\n\r\n// Test function to verify video streaming functionality\r\nexport const testVideoStreaming = async () => {\r\n  console.log('🧪 Testing Video Streaming Functionality...');\r\n\r\n  // Test data - specific movies mentioned by user\r\n  const testMovies = [\r\n    { id: '278', name: 'Shawshank Redemption' },\r\n    { id: '155', name: 'The Dark Knight' },\r\n    { id: '550', name: 'Fight Club' }\r\n  ];\r\n  const testTVId = '1399'; // Game of Thrones\r\n\r\n  try {\r\n    // Test 1: Get movie sources for each test movie\r\n    console.log('\\n📽️ Testing Movie Sources...');\r\n    for (const movie of testMovies) {\r\n      const movieSources = vidsrcApi.getMovieSources(movie.id, { includeAlternatives: true });\r\n      console.log(`Found ${movieSources.length} sources for ${movie.name} (${movie.id})`);\r\n    }\r\n\r\n    // Test 2: Get TV sources\r\n    console.log('\\n📺 Testing TV Sources...');\r\n    const tvSources = vidsrcApi.getTVSources(testTVId, 1, 1, { includeAlternatives: true });\r\n    console.log(`Found ${tvSources.length} TV sources`);\r\n\r\n    // Test 3: Test specific movies for availability\r\n    console.log('\\n🔍 Testing Specific Movie Availability...');\r\n    for (const movie of testMovies) {\r\n      console.log(`\\n--- Testing ${movie.name} (${movie.id}) ---`);\r\n\r\n      // Test the primary source\r\n      const primaryStream = vidsrcApi.getMovieStream(movie.id, { quality: '1080p' });\r\n      console.log(`Primary URL: ${primaryStream.url}`);\r\n\r\n      try {\r\n        const result = await vidsrcApi.testStream(primaryStream.url, 5000);\r\n        console.log(`✅ Primary: ${result.available ? 'Available' : 'Failed'} (${result.loadTime}ms)`);\r\n\r\n        if (result.available) {\r\n          console.log(`🎉 SUCCESS: ${movie.name} is working!`);\r\n        } else {\r\n          console.log(`❌ Primary failed, trying alternatives...`);\r\n\r\n          // Try alternative sources\r\n          const altUrls = vidsrcApi.tryAlternativeUrls(movie.id, 'movie');\r\n          console.log(`Found ${altUrls.length} alternative URLs`);\r\n\r\n          for (let i = 0; i < Math.min(3, altUrls.length); i++) {\r\n            try {\r\n              const altResult = await vidsrcApi.testStream(altUrls[i], 3000);\r\n              console.log(`  Alt ${i + 1}: ${altResult.available ? 'Available' : 'Failed'} (${altResult.loadTime}ms)`);\r\n              if (altResult.available) {\r\n                console.log(`  🎉 Alternative ${i + 1} works!`);\r\n                break;\r\n              }\r\n            } catch (altError) {\r\n              console.log(`  Alt ${i + 1}: Error - ${altError.message}`);\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.log(`❌ Error testing ${movie.name}: ${error.message}`);\r\n      }\r\n    }\r\n\r\n    // Test 4: Test fallback system\r\n    console.log('\\n🔄 Testing Fallback System...');\r\n    const fallbackStatus = vidsrcApi.getFallbackStatus();\r\n    console.log('Fallback Status:', fallbackStatus);\r\n\r\n    console.log('\\n✅ Video streaming test completed!');\r\n    return {\r\n      success: true,\r\n      testedMovies: testMovies.length,\r\n      tvSources: tvSources.length\r\n    };\r\n\r\n  } catch (error) {\r\n    console.error('❌ Video streaming test failed:', error);\r\n    return {\r\n      success: false,\r\n      error: error.message\r\n    };\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}