{"ast":null,"code":"// VidSrc API service for streaming integration\n// No API key required - uses TMDB IDs directly\n\n// Simplified domain configuration - vidsrc.net as primary source\nconst VIDSRC_DOMAINS = {\n  primary: 'https://vidsrc.net/embed',\n  fallbacks: ['https://vidsrc.to/embed', 'https://vidsrc.cc/embed']\n};\n\n// Quality options for streaming\nconst QualityOptions = {\n  AUTO: 'auto',\n  Q4K: '4k',\n  Q1080P: '1080p',\n  Q720P: '720p',\n  Q480P: '480p',\n  Q360P: '360p'\n};\n\n// Error types for better error handling\nconst StreamErrorTypes = {\n  NETWORK_ERROR: 'NETWORK_ERROR',\n  TIMEOUT_ERROR: 'TIMEOUT_ERROR',\n  PLAYER_ERROR: 'PLAYER_ERROR',\n  CONTENT_NOT_FOUND: 'CONTENT_NOT_FOUND',\n  GEO_BLOCKED: 'GEO_BLOCKED',\n  QUALITY_UNAVAILABLE: 'QUALITY_UNAVAILABLE'\n};\nexport const vidsrcApi = {\n  // Simple streaming URL generation using vidsrc.net\n  getMovieStream: (tmdbId, options = {}) => {\n    const {\n      quality = 'auto'\n    } = options;\n    const url = `${VIDSRC_DOMAINS.primary}/movie/${tmdbId}${quality !== 'auto' ? `?q=${quality}` : ''}`;\n    return {\n      url,\n      type: 'movie',\n      provider: 'vidsrc',\n      embeddable: true,\n      quality\n    };\n  },\n  // Simple TV streaming using vidsrc.net\n  getTVStream: (tmdbId, season = 1, episode = 1, options = {}) => {\n    const {\n      quality = 'auto'\n    } = options;\n    const url = `${VIDSRC_DOMAINS.primary}/tv/${tmdbId}/${season}/${episode}${quality !== 'auto' ? `?q=${quality}` : ''}`;\n    return {\n      url,\n      type: 'tv',\n      provider: 'vidsrc',\n      embeddable: true,\n      season,\n      episode,\n      quality\n    };\n  },\n  // Get error stream for failed requests\n  getErrorStream: (type, id, error, season = null, episode = null) => {\n    return {\n      url: '',\n      type,\n      provider: 'error',\n      embeddable: false,\n      error: error.message,\n      season,\n      episode\n    };\n  },\n  // Check if streaming is available for a movie\n  checkAvailability: async (tmdbId, type = 'movie') => {\n    try {\n      // VidSrc doesn't have a formal availability check API\n      // We assume content is available if it has a valid TMDB ID\n      return {\n        available: true,\n        provider: 'vidsrc',\n        embeddable: true,\n        message: 'Streaming available via VidSrc'\n      };\n    } catch (error) {\n      return {\n        available: false,\n        provider: 'vidsrc',\n        embeddable: false,\n        message: 'Streaming temporarily unavailable'\n      };\n    }\n  },\n  // Get streaming quality information\n  getQualityInfo: () => {\n    return {\n      default: '1080p',\n      available: ['720p', '1080p', '4K'],\n      note: 'Quality automatically adjusts based on connection speed'\n    };\n  },\n  // Get supported regions\n  getSupportedRegions: () => {\n    return {\n      regions: ['IN', 'US', 'UK', 'CA', 'AU', 'DE', 'FR', 'JP', 'KR', 'BR', 'MX', 'ES', 'IT', 'NL', 'SE', 'NO', 'DK', 'FI', 'PL', 'RU', 'CN', 'HK', 'TW', 'SG', 'MY', 'TH', 'VN', 'PH', 'ID', 'AE', 'SA', 'EG', 'ZA', 'NG', 'KE', 'MA', 'TN', 'DZ', 'AR', 'CL', 'CO', 'PE', 'VE', 'EC', 'UY', 'PY', 'BO', 'GT', 'CR', 'PA', 'DO', 'JM', 'TT', 'BB', 'LC', 'VC', 'GD', 'AG', 'DM', 'KN', 'MS', 'VG', 'AI', 'BM', 'KY', 'TC', 'FK', 'GS', 'SH', 'IO', 'AC', 'TA', 'PN', 'WF', 'PF', 'NC', 'VU', 'FJ', 'PG', 'SB', 'KI', 'NR', 'TV', 'TO', 'WS', 'CK', 'NU', 'TK', 'AS', 'GU', 'MP', 'FM', 'MH', 'PW', 'UM', 'VI', 'PR'],\n      note: 'VidSrc works globally with no regional restrictions'\n    };\n  },\n  // Enhanced error handling with recovery\n  handleStreamError: async (error, context) => {\n    performanceMonitor.trackError(error);\n    try {\n      const recoveredUrl = await errorRecoveryManager.recover(error, context);\n      fallbackManager.recordSuccess();\n      return {\n        success: true,\n        url: recoveredUrl,\n        recovered: true\n      };\n    } catch (recoveryError) {\n      fallbackManager.recordFailure();\n      return {\n        success: false,\n        error: recoveryError.message,\n        fallbackExhausted: true\n      };\n    }\n  },\n  // Get available quality options\n  getQualityOptions: (contentType = 'movie') => {\n    const baseQualities = [QualityOptions.Q1080P, QualityOptions.Q720P, QualityOptions.Q480P];\n    if (contentType === 'movie') {\n      baseQualities.unshift(QualityOptions.Q4K);\n    }\n    return baseQualities;\n  },\n  // Get performance metrics\n  getPerformanceReport: () => {\n    return performanceMonitor.generateReport();\n  },\n  // Test multiple sources and return the first working one\n  testMultipleSources: async (sources, options = {}) => {\n    const {\n      timeout = 8000,\n      maxConcurrent = 3\n    } = options;\n    const workingSources = [];\n    const failedSources = [];\n    console.log(`🔍 [DEBUG] Starting comprehensive source testing`);\n    console.log(`🔍 [DEBUG] Total sources: ${sources.length}, Timeout: ${timeout}ms, Max concurrent: ${maxConcurrent}`);\n\n    // Test sources in batches to avoid overwhelming servers\n    for (let i = 0; i < sources.length; i += maxConcurrent) {\n      const batch = sources.slice(i, i + maxConcurrent);\n      console.log(`🔍 [DEBUG] Testing batch ${Math.floor(i / maxConcurrent) + 1}/${Math.ceil(sources.length / maxConcurrent)}`);\n      const batchPromises = batch.map(async source => {\n        const startTime = Date.now();\n        try {\n          console.log(`🔍 [DEBUG] Testing: ${source.name || source.id} (${source.provider})`);\n          const result = await vidsrcApi.testStream(source.url, timeout);\n          const testTime = Date.now() - startTime;\n          console.log(`🔍 [DEBUG] Result: ${result.available ? '✅' : '❌'} ${source.name || source.id} (${testTime}ms)`);\n          return {\n            source,\n            result\n          };\n        } catch (error) {\n          const testTime = Date.now() - startTime;\n          console.log(`🔍 [DEBUG] Error: ❌ ${source.name || source.id} - ${error.message} (${testTime}ms)`);\n          return {\n            source,\n            result: {\n              available: false,\n              error: error.message,\n              errorType: 'TEST_ERROR'\n            }\n          };\n        }\n      });\n      const batchResults = await Promise.all(batchPromises);\n      batchResults.forEach(({\n        source,\n        result\n      }) => {\n        if (result.available) {\n          workingSources.push({\n            ...source,\n            testResult: result\n          });\n          console.log(`✅ [DEBUG] Working source found: ${source.name || source.id}`);\n        } else {\n          failedSources.push({\n            ...source,\n            testResult: result\n          });\n          console.log(`❌ [DEBUG] Failed source: ${source.name || source.id} - ${result.error || 'Unknown error'}`);\n        }\n      });\n    }\n    const successRate = sources.length > 0 ? workingSources.length / sources.length * 100 : 0;\n    console.log(`📊 [DEBUG] Testing complete: ${workingSources.length}/${sources.length} working (${successRate.toFixed(1)}%)`);\n    return {\n      working: workingSources,\n      failed: failedSources,\n      total: sources.length,\n      successRate\n    };\n  },\n  // Enhanced method to find the first working source quickly\n  findFirstWorkingSource: async (sources, options = {}) => {\n    const {\n      timeout = 5000,\n      maxConcurrent = 5\n    } = options;\n    console.log(`🔍 [DEBUG] Starting source testing for ${sources.length} sources`);\n    console.log(`🔍 [DEBUG] Timeout: ${timeout}ms, Max concurrent: ${maxConcurrent}`);\n\n    // Test sources in parallel batches\n    for (let i = 0; i < sources.length; i += maxConcurrent) {\n      const batch = sources.slice(i, i + maxConcurrent);\n      console.log(`🔍 [DEBUG] Testing batch ${Math.floor(i / maxConcurrent) + 1}: ${batch.map(s => s.name || s.id).join(', ')}`);\n      const batchPromises = batch.map(async source => {\n        const startTime = Date.now();\n        try {\n          console.log(`🔍 [DEBUG] Testing source: ${source.name || source.id} - ${source.url}`);\n          const result = await vidsrcApi.testStream(source.url, timeout);\n          const testTime = Date.now() - startTime;\n          console.log(`🔍 [DEBUG] Source ${source.name || source.id}: ${result.available ? '✅ AVAILABLE' : '❌ FAILED'} (${testTime}ms)`);\n          if (!result.available) {\n            console.log(`🔍 [DEBUG] Source ${source.name || source.id} failed: ${result.error || 'Unknown error'}`);\n          }\n          if (result.available) {\n            return {\n              source,\n              result,\n              success: true\n            };\n          }\n          return {\n            source,\n            result,\n            success: false\n          };\n        } catch (error) {\n          const testTime = Date.now() - startTime;\n          console.log(`🔍 [DEBUG] Source ${source.name || source.id} error: ${error.message} (${testTime}ms)`);\n          return {\n            source,\n            result: {\n              available: false,\n              error: error.message\n            },\n            success: false\n          };\n        }\n      });\n      const batchResults = await Promise.all(batchPromises);\n\n      // Return the first working source found\n      const workingSource = batchResults.find(result => result.success);\n      if (workingSource) {\n        console.log(`🎉 [DEBUG] Found working source: ${workingSource.source.name || workingSource.source.id}`);\n        console.log(`🎉 [DEBUG] URL: ${workingSource.source.url}`);\n        console.log(`🎉 [DEBUG] Provider: ${workingSource.source.provider}`);\n        return workingSource;\n      }\n    }\n    console.log(`❌ [DEBUG] No working sources found after testing all ${sources.length} sources`);\n    return null; // No working sources found\n  },\n  // Get best available source with automatic testing\n  getBestAvailableSource: async (tmdbId, type, season = null, episode = null, options = {}) => {\n    const {\n      testSources = true,\n      quality = 'auto'\n    } = options;\n\n    // Get all available sources\n    const sources = type === 'movie' ? vidsrcApi.getMovieSources(tmdbId, {\n      includeAlternatives: true,\n      quality\n    }) : vidsrcApi.getTVSources(tmdbId, season, episode, {\n      includeAlternatives: true,\n      quality\n    });\n    if (!testSources) {\n      return sources[0]; // Return first source without testing\n    }\n\n    // Test sources and return the first working one\n    const testResult = await vidsrcApi.testMultipleSources(sources);\n    if (testResult.working.length > 0) {\n      return testResult.working[0];\n    }\n\n    // If no sources work, return the primary source with error info\n    return {\n      ...sources[0],\n      testResult: {\n        available: false,\n        error: 'No working sources found',\n        errorType: 'ALL_SOURCES_FAILED'\n      }\n    };\n  },\n  // Reset fallback manager\n  resetFallbackManager: () => {\n    fallbackManager.reset();\n    performanceMonitor.startTracking();\n  },\n  // Get current fallback status\n  getFallbackStatus: () => {\n    return {\n      currentDomain: fallbackManager.getCurrentDomain(),\n      retryCount: fallbackManager.retryCount,\n      domainLevel: fallbackManager.domainLevel,\n      maxRetries: fallbackManager.maxRetries\n    };\n  },\n  // Manual source verification as backup when automatic testing fails\n  verifySourceManually: async (url, timeout = 10000) => {\n    console.log(`🔍 [Manual] Starting manual verification for: ${url}`);\n    return new Promise(resolve => {\n      const iframe = document.createElement('iframe');\n      iframe.src = url;\n      iframe.style.display = 'none';\n      iframe.sandbox = 'allow-same-origin allow-scripts allow-presentation';\n      const startTime = Date.now();\n      let hasLoaded = false;\n      let hasError = false;\n      const cleanup = () => {\n        if (iframe.parentNode) {\n          iframe.parentNode.removeChild(iframe);\n        }\n        clearTimeout(timeoutId);\n      };\n      const timeoutId = setTimeout(() => {\n        if (!hasLoaded && !hasError) {\n          console.log(`⏱️ [Manual] Manual verification timeout for: ${url}`);\n          cleanup();\n          resolve({\n            available: false,\n            error: 'Manual verification timeout',\n            errorType: 'TIMEOUT_ERROR',\n            method: 'manual-iframe',\n            loadTime: Date.now() - startTime\n          });\n        }\n      }, timeout);\n      iframe.onload = () => {\n        hasLoaded = true;\n        const loadTime = Date.now() - startTime;\n        console.log(`✅ [Manual] Manual verification success for: ${url} (${loadTime}ms)`);\n\n        // Additional check: try to access iframe content\n        try {\n          const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\n          const hasVideoElement = iframeDoc.querySelector('video') !== null;\n          const hasPlayerContainer = iframeDoc.querySelector('.player, #player, [class*=\"player\"]') !== null;\n          const isErrorPage = iframeDoc.body && iframeDoc.body.textContent.includes('not found');\n          if (isErrorPage) {\n            cleanup();\n            resolve({\n              available: false,\n              error: 'Video not found (detected error page)',\n              errorType: 'CONTENT_NOT_FOUND',\n              method: 'manual-iframe',\n              loadTime,\n              hasVideoElement,\n              hasPlayerContainer\n            });\n          } else if (hasVideoElement || hasPlayerContainer) {\n            cleanup();\n            resolve({\n              available: true,\n              loadTime,\n              method: 'manual-iframe',\n              hasVideoElement,\n              hasPlayerContainer\n            });\n          } else {\n            // Give it a bit more time to load video content\n            setTimeout(() => {\n              try {\n                const finalDoc = iframe.contentDocument || iframe.contentWindow.document;\n                const finalVideoElement = finalDoc.querySelector('video') !== null;\n                const finalPlayerContainer = finalDoc.querySelector('.player, #player, [class*=\"player\"]') !== null;\n                cleanup();\n                resolve({\n                  available: finalVideoElement || finalPlayerContainer,\n                  loadTime: Date.now() - startTime,\n                  method: 'manual-iframe',\n                  hasVideoElement: finalVideoElement,\n                  hasPlayerContainer: finalPlayerContainer\n                });\n              } catch (e) {\n                cleanup();\n                resolve({\n                  available: true,\n                  // Assume it's working if we can't check content\n                  loadTime: Date.now() - startTime,\n                  method: 'manual-iframe',\n                  note: 'Could not verify content due to CORS, assuming available'\n                });\n              }\n            }, 2000);\n          }\n        } catch (e) {\n          // CORS restriction - assume it's working if it loaded\n          cleanup();\n          resolve({\n            available: true,\n            loadTime,\n            method: 'manual-iframe',\n            note: 'Could not verify content due to CORS, assuming available'\n          });\n        }\n      };\n      iframe.onerror = () => {\n        hasError = true;\n        const loadTime = Date.now() - startTime;\n        console.log(`❌ [Manual] Manual verification failed for: ${url} (${loadTime}ms)`);\n        cleanup();\n        resolve({\n          available: false,\n          error: 'Failed to load iframe',\n          errorType: 'NETWORK_ERROR',\n          method: 'manual-iframe',\n          loadTime\n        });\n      };\n      document.body.appendChild(iframe);\n    });\n  },\n  // Create secure iframe embed\n  createSecureEmbed: (streamData, options = {}) => {\n    const {\n      width = '100%',\n      height = '500',\n      autoplay = false,\n      muted = false,\n      controls = true,\n      sandbox = 'allow-same-origin allow-scripts allow-presentation'\n    } = options;\n    const embedUrl = streamData.url;\n    return {\n      iframe: `<iframe\n        src=\"${embedUrl}\"\n        width=\"${width}\"\n        height=\"${height}\"\n        frameborder=\"0\"\n        allowfullscreen\n        ${autoplay ? 'autoplay' : ''}\n        ${muted ? 'muted' : ''}\n        ${controls ? '' : 'controls=\"false\"'}\n        sandbox=\"${sandbox}\"\n        allow=\"autoplay; encrypted-media; fullscreen; picture-in-picture\"\n        referrerpolicy=\"strict-origin-when-cross-origin\"\n        loading=\"lazy\"\n      ></iframe>`,\n      url: embedUrl,\n      type: streamData.type,\n      provider: streamData.provider,\n      security: {\n        sandbox,\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        cspCompliant: true\n      }\n    };\n  }\n};\n\n// Helper function to create iframe embed code\nexport const createEmbedCode = (streamData, options = {}) => {\n  const {\n    width = '100%',\n    height = '500',\n    autoplay = false,\n    muted = false,\n    controls = true\n  } = options;\n  const embedUrl = streamData.url;\n  return {\n    iframe: `<iframe\n      src=\"${embedUrl}\"\n      width=\"${width}\"\n      height=\"${height}\"\n      frameborder=\"0\"\n      allowfullscreen\n      ${autoplay ? 'autoplay' : ''}\n      ${muted ? 'muted' : ''}\n      ${controls ? '' : 'controls=\"false\"'}\n      sandbox=\"allow-same-origin allow-scripts allow-presentation\"\n    ></iframe>`,\n    url: embedUrl,\n    type: streamData.type,\n    provider: streamData.provider\n  };\n};\n\n// Error handling for streaming\nexport const handleStreamError = (error, fallbackSources = []) => {\n  console.error('Streaming error:', error);\n  if (fallbackSources.length > 0) {\n    return {\n      success: false,\n      error: error.message,\n      fallback: fallbackSources[0],\n      hasFallback: true\n    };\n  }\n  return {\n    success: false,\n    error: error.message,\n    hasFallback: false\n  };\n};\nexport default vidsrcApi;\n\n// Test function to verify video streaming functionality\nexport const testVideoStreaming = async () => {\n  console.log('🧪 Testing Video Streaming Functionality...');\n\n  // Test data - specific movies mentioned by user\n  const testMovies = [{\n    id: '278',\n    name: 'Shawshank Redemption'\n  }, {\n    id: '155',\n    name: 'The Dark Knight'\n  }, {\n    id: '550',\n    name: 'Fight Club'\n  }];\n  const testTVId = '1399'; // Game of Thrones\n\n  try {\n    // Test 1: Get movie sources for each test movie\n    console.log('\\n📽️ Testing Movie Sources...');\n    for (const movie of testMovies) {\n      const movieSources = vidsrcApi.getMovieSources(movie.id, {\n        includeAlternatives: true\n      });\n      console.log(`Found ${movieSources.length} sources for ${movie.name} (${movie.id})`);\n    }\n\n    // Test 2: Get TV sources\n    console.log('\\n📺 Testing TV Sources...');\n    const tvSources = vidsrcApi.getTVSources(testTVId, 1, 1, {\n      includeAlternatives: true\n    });\n    console.log(`Found ${tvSources.length} TV sources`);\n\n    // Test 3: Test specific movies for availability\n    console.log('\\n🔍 Testing Specific Movie Availability...');\n    for (const movie of testMovies) {\n      console.log(`\\n--- Testing ${movie.name} (${movie.id}) ---`);\n\n      // Test the primary source\n      const primaryStream = vidsrcApi.getMovieStream(movie.id, {\n        quality: '1080p'\n      });\n      console.log(`Primary URL: ${primaryStream.url}`);\n      try {\n        const result = await vidsrcApi.testStream(primaryStream.url, 5000);\n        console.log(`✅ Primary: ${result.available ? 'Available' : 'Failed'} (${result.loadTime}ms)`);\n        if (result.available) {\n          console.log(`🎉 SUCCESS: ${movie.name} is working!`);\n        } else {\n          console.log(`❌ Primary failed, trying alternatives...`);\n\n          // Try alternative sources\n          const altUrls = vidsrcApi.tryAlternativeUrls(movie.id, 'movie');\n          console.log(`Found ${altUrls.length} alternative URLs`);\n          for (let i = 0; i < Math.min(3, altUrls.length); i++) {\n            try {\n              const altResult = await vidsrcApi.testStream(altUrls[i], 3000);\n              console.log(`  Alt ${i + 1}: ${altResult.available ? 'Available' : 'Failed'} (${altResult.loadTime}ms)`);\n              if (altResult.available) {\n                console.log(`  🎉 Alternative ${i + 1} works!`);\n                break;\n              }\n            } catch (altError) {\n              console.log(`  Alt ${i + 1}: Error - ${altError.message}`);\n            }\n          }\n        }\n      } catch (error) {\n        console.log(`❌ Error testing ${movie.name}: ${error.message}`);\n      }\n    }\n\n    // Test 4: Test fallback system\n    console.log('\\n🔄 Testing Fallback System...');\n    const fallbackStatus = vidsrcApi.getFallbackStatus();\n    console.log('Fallback Status:', fallbackStatus);\n    console.log('\\n✅ Video streaming test completed!');\n    return {\n      success: true,\n      testedMovies: testMovies.length,\n      tvSources: tvSources.length\n    };\n  } catch (error) {\n    console.error('❌ Video streaming test failed:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n};","map":{"version":3,"names":["VIDSRC_DOMAINS","primary","fallbacks","QualityOptions","AUTO","Q4K","Q1080P","Q720P","Q480P","Q360P","StreamErrorTypes","NETWORK_ERROR","TIMEOUT_ERROR","PLAYER_ERROR","CONTENT_NOT_FOUND","GEO_BLOCKED","QUALITY_UNAVAILABLE","vidsrcApi","getMovieStream","tmdbId","options","quality","url","type","provider","embeddable","getTVStream","season","episode","getErrorStream","id","error","message","checkAvailability","available","getQualityInfo","default","note","getSupportedRegions","regions","handleStreamError","context","performanceMonitor","trackError","recoveredUrl","errorRecoveryManager","recover","fallbackManager","recordSuccess","success","recovered","recoveryError","recordFailure","fallbackExhausted","getQualityOptions","contentType","baseQualities","unshift","getPerformanceReport","generateReport","testMultipleSources","sources","timeout","maxConcurrent","workingSources","failedSources","console","log","length","i","batch","slice","Math","floor","ceil","batchPromises","map","source","startTime","Date","now","name","result","testStream","testTime","errorType","batchResults","Promise","all","forEach","push","testResult","successRate","toFixed","working","failed","total","findFirstWorkingSource","s","join","workingSource","find","getBestAvailableSource","testSources","getMovieSources","includeAlternatives","getTVSources","resetFallbackManager","reset","startTracking","getFallbackStatus","currentDomain","getCurrentDomain","retryCount","domainLevel","maxRetries","verifySourceManually","resolve","iframe","document","createElement","src","style","display","sandbox","hasLoaded","hasError","cleanup","parentNode","removeChild","clearTimeout","timeoutId","setTimeout","method","loadTime","onload","iframeDoc","contentDocument","contentWindow","hasVideoElement","querySelector","hasPlayerContainer","isErrorPage","body","textContent","includes","finalDoc","finalVideoElement","finalPlayerContainer","e","onerror","appendChild","createSecureEmbed","streamData","width","height","autoplay","muted","controls","embedUrl","security","referrerPolicy","cspCompliant","createEmbedCode","fallbackSources","fallback","hasFallback","testVideoStreaming","testMovies","testTVId","movie","movieSources","tvSources","primaryStream","altUrls","tryAlternativeUrls","min","altResult","altError","fallbackStatus","testedMovies"],"sources":["c:/Users/VASU/Desktop/task/src/services/vidsrcApi.js"],"sourcesContent":["// VidSrc API service for streaming integration\r\n// No API key required - uses TMDB IDs directly\r\n\r\n// Simplified domain configuration - vidsrc.net as primary source\r\nconst VIDSRC_DOMAINS = {\r\n  primary: 'https://vidsrc.net/embed',\r\n  fallbacks: [\r\n    'https://vidsrc.to/embed',\r\n    'https://vidsrc.cc/embed'\r\n  ]\r\n};\r\n\r\n// Quality options for streaming\r\nconst QualityOptions = {\r\n  AUTO: 'auto',\r\n  Q4K: '4k',\r\n  Q1080P: '1080p',\r\n  Q720P: '720p',\r\n  Q480P: '480p',\r\n  Q360P: '360p'\r\n};\r\n\r\n// Error types for better error handling\r\nconst StreamErrorTypes = {\r\n  NETWORK_ERROR: 'NETWORK_ERROR',\r\n  TIMEOUT_ERROR: 'TIMEOUT_ERROR',\r\n  PLAYER_ERROR: 'PLAYER_ERROR',\r\n  CONTENT_NOT_FOUND: 'CONTENT_NOT_FOUND',\r\n  GEO_BLOCKED: 'GEO_BLOCKED',\r\n  QUALITY_UNAVAILABLE: 'QUALITY_UNAVAILABLE'\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\nexport const vidsrcApi = {\r\n  // Simple streaming URL generation using vidsrc.net\r\n  getMovieStream: (tmdbId, options = {}) => {\r\n    const { quality = 'auto' } = options;\r\n\r\n    const url = `${VIDSRC_DOMAINS.primary}/movie/${tmdbId}${quality !== 'auto' ? `?q=${quality}` : ''}`;\r\n\r\n    return {\r\n      url,\r\n      type: 'movie',\r\n      provider: 'vidsrc',\r\n      embeddable: true,\r\n      quality\r\n    };\r\n  },\r\n\r\n  // Simple TV streaming using vidsrc.net\r\n  getTVStream: (tmdbId, season = 1, episode = 1, options = {}) => {\r\n    const { quality = 'auto' } = options;\r\n\r\n    const url = `${VIDSRC_DOMAINS.primary}/tv/${tmdbId}/${season}/${episode}${quality !== 'auto' ? `?q=${quality}` : ''}`;\r\n\r\n    return {\r\n      url,\r\n      type: 'tv',\r\n      provider: 'vidsrc',\r\n      embeddable: true,\r\n      season,\r\n      episode,\r\n      quality\r\n    };\r\n  },\r\n\r\n  // Get error stream for failed requests\r\n  getErrorStream: (type, id, error, season = null, episode = null) => {\r\n    return {\r\n      url: '',\r\n      type,\r\n      provider: 'error',\r\n      embeddable: false,\r\n      error: error.message,\r\n      season,\r\n      episode\r\n    };\r\n  },\r\n\r\n\r\n\r\n\r\n  // Check if streaming is available for a movie\r\n  checkAvailability: async (tmdbId, type = 'movie') => {\r\n    try {\r\n      // VidSrc doesn't have a formal availability check API\r\n      // We assume content is available if it has a valid TMDB ID\r\n      return {\r\n        available: true,\r\n        provider: 'vidsrc',\r\n        embeddable: true,\r\n        message: 'Streaming available via VidSrc'\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        available: false,\r\n        provider: 'vidsrc',\r\n        embeddable: false,\r\n        message: 'Streaming temporarily unavailable'\r\n      };\r\n    }\r\n  },\r\n\r\n  // Get streaming quality information\r\n  getQualityInfo: () => {\r\n    return {\r\n      default: '1080p',\r\n      available: ['720p', '1080p', '4K'],\r\n      note: 'Quality automatically adjusts based on connection speed'\r\n    };\r\n  },\r\n\r\n  // Get supported regions\r\n  getSupportedRegions: () => {\r\n    return {\r\n      regions: ['IN', 'US', 'UK', 'CA', 'AU', 'DE', 'FR', 'JP', 'KR', 'BR', 'MX', 'ES', 'IT', 'NL', 'SE', 'NO', 'DK', 'FI', 'PL', 'RU', 'CN', 'HK', 'TW', 'SG', 'MY', 'TH', 'VN', 'PH', 'ID', 'AE', 'SA', 'EG', 'ZA', 'NG', 'KE', 'MA', 'TN', 'DZ', 'AR', 'CL', 'CO', 'PE', 'VE', 'EC', 'UY', 'PY', 'BO', 'GT', 'CR', 'PA', 'DO', 'JM', 'TT', 'BB', 'LC', 'VC', 'GD', 'AG', 'DM', 'KN', 'MS', 'VG', 'AI', 'BM', 'KY', 'TC', 'FK', 'GS', 'SH', 'IO', 'AC', 'TA', 'PN', 'WF', 'PF', 'NC', 'VU', 'FJ', 'PG', 'SB', 'KI', 'NR', 'TV', 'TO', 'WS', 'CK', 'NU', 'TK', 'AS', 'GU', 'MP', 'FM', 'MH', 'PW', 'UM', 'VI', 'PR'],\r\n      note: 'VidSrc works globally with no regional restrictions'\r\n    };\r\n  },\r\n\r\n  // Enhanced error handling with recovery\r\n  handleStreamError: async (error, context) => {\r\n    performanceMonitor.trackError(error);\r\n\r\n    try {\r\n      const recoveredUrl = await errorRecoveryManager.recover(error, context);\r\n      fallbackManager.recordSuccess();\r\n      return {\r\n        success: true,\r\n        url: recoveredUrl,\r\n        recovered: true\r\n      };\r\n    } catch (recoveryError) {\r\n      fallbackManager.recordFailure();\r\n      return {\r\n        success: false,\r\n        error: recoveryError.message,\r\n        fallbackExhausted: true\r\n      };\r\n    }\r\n  },\r\n\r\n  // Get available quality options\r\n  getQualityOptions: (contentType = 'movie') => {\r\n    const baseQualities = [QualityOptions.Q1080P, QualityOptions.Q720P, QualityOptions.Q480P];\r\n\r\n    if (contentType === 'movie') {\r\n      baseQualities.unshift(QualityOptions.Q4K);\r\n    }\r\n\r\n    return baseQualities;\r\n  },\r\n\r\n\r\n  // Get performance metrics\r\n  getPerformanceReport: () => {\r\n    return performanceMonitor.generateReport();\r\n  },\r\n\r\n  // Test multiple sources and return the first working one\r\n  testMultipleSources: async (sources, options = {}) => {\r\n    const { timeout = 8000, maxConcurrent = 3 } = options;\r\n    const workingSources = [];\r\n    const failedSources = [];\r\n\r\n    console.log(`🔍 [DEBUG] Starting comprehensive source testing`);\r\n    console.log(`🔍 [DEBUG] Total sources: ${sources.length}, Timeout: ${timeout}ms, Max concurrent: ${maxConcurrent}`);\r\n\r\n    // Test sources in batches to avoid overwhelming servers\r\n    for (let i = 0; i < sources.length; i += maxConcurrent) {\r\n      const batch = sources.slice(i, i + maxConcurrent);\r\n      console.log(`🔍 [DEBUG] Testing batch ${Math.floor(i/maxConcurrent) + 1}/${Math.ceil(sources.length/maxConcurrent)}`);\r\n\r\n      const batchPromises = batch.map(async (source) => {\r\n        const startTime = Date.now();\r\n        try {\r\n          console.log(`🔍 [DEBUG] Testing: ${source.name || source.id} (${source.provider})`);\r\n          const result = await vidsrcApi.testStream(source.url, timeout);\r\n          const testTime = Date.now() - startTime;\r\n\r\n          console.log(`🔍 [DEBUG] Result: ${result.available ? '✅' : '❌'} ${source.name || source.id} (${testTime}ms)`);\r\n\r\n          return { source, result };\r\n        } catch (error) {\r\n          const testTime = Date.now() - startTime;\r\n          console.log(`🔍 [DEBUG] Error: ❌ ${source.name || source.id} - ${error.message} (${testTime}ms)`);\r\n          return {\r\n            source,\r\n            result: {\r\n              available: false,\r\n              error: error.message,\r\n              errorType: 'TEST_ERROR'\r\n            }\r\n          };\r\n        }\r\n      });\r\n\r\n      const batchResults = await Promise.all(batchPromises);\r\n\r\n      batchResults.forEach(({ source, result }) => {\r\n        if (result.available) {\r\n          workingSources.push({ ...source, testResult: result });\r\n          console.log(`✅ [DEBUG] Working source found: ${source.name || source.id}`);\r\n        } else {\r\n          failedSources.push({ ...source, testResult: result });\r\n          console.log(`❌ [DEBUG] Failed source: ${source.name || source.id} - ${result.error || 'Unknown error'}`);\r\n        }\r\n      });\r\n    }\r\n\r\n    const successRate = sources.length > 0 ? (workingSources.length / sources.length) * 100 : 0;\r\n    console.log(`📊 [DEBUG] Testing complete: ${workingSources.length}/${sources.length} working (${successRate.toFixed(1)}%)`);\r\n\r\n    return {\r\n      working: workingSources,\r\n      failed: failedSources,\r\n      total: sources.length,\r\n      successRate\r\n    };\r\n  },\r\n\r\n  // Enhanced method to find the first working source quickly\r\n  findFirstWorkingSource: async (sources, options = {}) => {\r\n    const { timeout = 5000, maxConcurrent = 5 } = options;\r\n\r\n    console.log(`🔍 [DEBUG] Starting source testing for ${sources.length} sources`);\r\n    console.log(`🔍 [DEBUG] Timeout: ${timeout}ms, Max concurrent: ${maxConcurrent}`);\r\n\r\n    // Test sources in parallel batches\r\n    for (let i = 0; i < sources.length; i += maxConcurrent) {\r\n      const batch = sources.slice(i, i + maxConcurrent);\r\n      console.log(`🔍 [DEBUG] Testing batch ${Math.floor(i/maxConcurrent) + 1}: ${batch.map(s => s.name || s.id).join(', ')}`);\r\n\r\n      const batchPromises = batch.map(async (source) => {\r\n        const startTime = Date.now();\r\n        try {\r\n          console.log(`🔍 [DEBUG] Testing source: ${source.name || source.id} - ${source.url}`);\r\n          const result = await vidsrcApi.testStream(source.url, timeout);\r\n\r\n          const testTime = Date.now() - startTime;\r\n          console.log(`🔍 [DEBUG] Source ${source.name || source.id}: ${result.available ? '✅ AVAILABLE' : '❌ FAILED'} (${testTime}ms)`);\r\n\r\n          if (!result.available) {\r\n            console.log(`🔍 [DEBUG] Source ${source.name || source.id} failed: ${result.error || 'Unknown error'}`);\r\n          }\r\n\r\n          if (result.available) {\r\n            return { source, result, success: true };\r\n          }\r\n          return { source, result, success: false };\r\n        } catch (error) {\r\n          const testTime = Date.now() - startTime;\r\n          console.log(`🔍 [DEBUG] Source ${source.name || source.id} error: ${error.message} (${testTime}ms)`);\r\n          return { source, result: { available: false, error: error.message }, success: false };\r\n        }\r\n      });\r\n\r\n      const batchResults = await Promise.all(batchPromises);\r\n\r\n      // Return the first working source found\r\n      const workingSource = batchResults.find(result => result.success);\r\n      if (workingSource) {\r\n        console.log(`🎉 [DEBUG] Found working source: ${workingSource.source.name || workingSource.source.id}`);\r\n        console.log(`🎉 [DEBUG] URL: ${workingSource.source.url}`);\r\n        console.log(`🎉 [DEBUG] Provider: ${workingSource.source.provider}`);\r\n        return workingSource;\r\n      }\r\n    }\r\n\r\n    console.log(`❌ [DEBUG] No working sources found after testing all ${sources.length} sources`);\r\n    return null; // No working sources found\r\n  },\r\n\r\n  // Get best available source with automatic testing\r\n  getBestAvailableSource: async (tmdbId, type, season = null, episode = null, options = {}) => {\r\n    const { testSources = true, quality = 'auto' } = options;\r\n\r\n    // Get all available sources\r\n    const sources = type === 'movie'\r\n      ? vidsrcApi.getMovieSources(tmdbId, { includeAlternatives: true, quality })\r\n      : vidsrcApi.getTVSources(tmdbId, season, episode, { includeAlternatives: true, quality });\r\n\r\n    if (!testSources) {\r\n      return sources[0]; // Return first source without testing\r\n    }\r\n\r\n    // Test sources and return the first working one\r\n    const testResult = await vidsrcApi.testMultipleSources(sources);\r\n\r\n    if (testResult.working.length > 0) {\r\n      return testResult.working[0];\r\n    }\r\n\r\n    // If no sources work, return the primary source with error info\r\n    return {\r\n      ...sources[0],\r\n      testResult: {\r\n        available: false,\r\n        error: 'No working sources found',\r\n        errorType: 'ALL_SOURCES_FAILED'\r\n      }\r\n    };\r\n  },\r\n\r\n  // Reset fallback manager\r\n  resetFallbackManager: () => {\r\n    fallbackManager.reset();\r\n    performanceMonitor.startTracking();\r\n  },\r\n\r\n  // Get current fallback status\r\n  getFallbackStatus: () => {\r\n    return {\r\n      currentDomain: fallbackManager.getCurrentDomain(),\r\n      retryCount: fallbackManager.retryCount,\r\n      domainLevel: fallbackManager.domainLevel,\r\n      maxRetries: fallbackManager.maxRetries\r\n    };\r\n  },\r\n\r\n  // Manual source verification as backup when automatic testing fails\r\n  verifySourceManually: async (url, timeout = 10000) => {\r\n    console.log(`🔍 [Manual] Starting manual verification for: ${url}`);\r\n\r\n    return new Promise((resolve) => {\r\n      const iframe = document.createElement('iframe');\r\n      iframe.src = url;\r\n      iframe.style.display = 'none';\r\n      iframe.sandbox = 'allow-same-origin allow-scripts allow-presentation';\r\n\r\n      const startTime = Date.now();\r\n      let hasLoaded = false;\r\n      let hasError = false;\r\n\r\n      const cleanup = () => {\r\n        if (iframe.parentNode) {\r\n          iframe.parentNode.removeChild(iframe);\r\n        }\r\n        clearTimeout(timeoutId);\r\n      };\r\n\r\n      const timeoutId = setTimeout(() => {\r\n        if (!hasLoaded && !hasError) {\r\n          console.log(`⏱️ [Manual] Manual verification timeout for: ${url}`);\r\n          cleanup();\r\n          resolve({\r\n            available: false,\r\n            error: 'Manual verification timeout',\r\n            errorType: 'TIMEOUT_ERROR',\r\n            method: 'manual-iframe',\r\n            loadTime: Date.now() - startTime\r\n          });\r\n        }\r\n      }, timeout);\r\n\r\n      iframe.onload = () => {\r\n        hasLoaded = true;\r\n        const loadTime = Date.now() - startTime;\r\n        console.log(`✅ [Manual] Manual verification success for: ${url} (${loadTime}ms)`);\r\n\r\n        // Additional check: try to access iframe content\r\n        try {\r\n          const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\r\n          const hasVideoElement = iframeDoc.querySelector('video') !== null;\r\n          const hasPlayerContainer = iframeDoc.querySelector('.player, #player, [class*=\"player\"]') !== null;\r\n          const isErrorPage = iframeDoc.body && iframeDoc.body.textContent.includes('not found');\r\n\r\n          if (isErrorPage) {\r\n            cleanup();\r\n            resolve({\r\n              available: false,\r\n              error: 'Video not found (detected error page)',\r\n              errorType: 'CONTENT_NOT_FOUND',\r\n              method: 'manual-iframe',\r\n              loadTime,\r\n              hasVideoElement,\r\n              hasPlayerContainer\r\n            });\r\n          } else if (hasVideoElement || hasPlayerContainer) {\r\n            cleanup();\r\n            resolve({\r\n              available: true,\r\n              loadTime,\r\n              method: 'manual-iframe',\r\n              hasVideoElement,\r\n              hasPlayerContainer\r\n            });\r\n          } else {\r\n            // Give it a bit more time to load video content\r\n            setTimeout(() => {\r\n              try {\r\n                const finalDoc = iframe.contentDocument || iframe.contentWindow.document;\r\n                const finalVideoElement = finalDoc.querySelector('video') !== null;\r\n                const finalPlayerContainer = finalDoc.querySelector('.player, #player, [class*=\"player\"]') !== null;\r\n\r\n                cleanup();\r\n                resolve({\r\n                  available: finalVideoElement || finalPlayerContainer,\r\n                  loadTime: Date.now() - startTime,\r\n                  method: 'manual-iframe',\r\n                  hasVideoElement: finalVideoElement,\r\n                  hasPlayerContainer: finalPlayerContainer\r\n                });\r\n              } catch (e) {\r\n                cleanup();\r\n                resolve({\r\n                  available: true, // Assume it's working if we can't check content\r\n                  loadTime: Date.now() - startTime,\r\n                  method: 'manual-iframe',\r\n                  note: 'Could not verify content due to CORS, assuming available'\r\n                });\r\n              }\r\n            }, 2000);\r\n          }\r\n        } catch (e) {\r\n          // CORS restriction - assume it's working if it loaded\r\n          cleanup();\r\n          resolve({\r\n            available: true,\r\n            loadTime,\r\n            method: 'manual-iframe',\r\n            note: 'Could not verify content due to CORS, assuming available'\r\n          });\r\n        }\r\n      };\r\n\r\n      iframe.onerror = () => {\r\n        hasError = true;\r\n        const loadTime = Date.now() - startTime;\r\n        console.log(`❌ [Manual] Manual verification failed for: ${url} (${loadTime}ms)`);\r\n        cleanup();\r\n        resolve({\r\n          available: false,\r\n          error: 'Failed to load iframe',\r\n          errorType: 'NETWORK_ERROR',\r\n          method: 'manual-iframe',\r\n          loadTime\r\n        });\r\n      };\r\n\r\n      document.body.appendChild(iframe);\r\n    });\r\n  },\r\n\r\n  // Create secure iframe embed\r\n  createSecureEmbed: (streamData, options = {}) => {\r\n    const {\r\n      width = '100%',\r\n      height = '500',\r\n      autoplay = false,\r\n      muted = false,\r\n      controls = true,\r\n      sandbox = 'allow-same-origin allow-scripts allow-presentation'\r\n    } = options;\r\n\r\n    const embedUrl = streamData.url;\r\n\r\n    return {\r\n      iframe: `<iframe\r\n        src=\"${embedUrl}\"\r\n        width=\"${width}\"\r\n        height=\"${height}\"\r\n        frameborder=\"0\"\r\n        allowfullscreen\r\n        ${autoplay ? 'autoplay' : ''}\r\n        ${muted ? 'muted' : ''}\r\n        ${controls ? '' : 'controls=\"false\"'}\r\n        sandbox=\"${sandbox}\"\r\n        allow=\"autoplay; encrypted-media; fullscreen; picture-in-picture\"\r\n        referrerpolicy=\"strict-origin-when-cross-origin\"\r\n        loading=\"lazy\"\r\n      ></iframe>`,\r\n      url: embedUrl,\r\n      type: streamData.type,\r\n      provider: streamData.provider,\r\n      security: {\r\n        sandbox,\r\n        referrerPolicy: 'strict-origin-when-cross-origin',\r\n        cspCompliant: true\r\n      }\r\n    };\r\n  }\r\n};\r\n\r\n// Helper function to create iframe embed code\r\nexport const createEmbedCode = (streamData, options = {}) => {\r\n  const {\r\n    width = '100%',\r\n    height = '500',\r\n    autoplay = false,\r\n    muted = false,\r\n    controls = true\r\n  } = options;\r\n\r\n  const embedUrl = streamData.url;\r\n\r\n  return {\r\n    iframe: `<iframe\r\n      src=\"${embedUrl}\"\r\n      width=\"${width}\"\r\n      height=\"${height}\"\r\n      frameborder=\"0\"\r\n      allowfullscreen\r\n      ${autoplay ? 'autoplay' : ''}\r\n      ${muted ? 'muted' : ''}\r\n      ${controls ? '' : 'controls=\"false\"'}\r\n      sandbox=\"allow-same-origin allow-scripts allow-presentation\"\r\n    ></iframe>`,\r\n    url: embedUrl,\r\n    type: streamData.type,\r\n    provider: streamData.provider\r\n  };\r\n};\r\n\r\n// Error handling for streaming\r\nexport const handleStreamError = (error, fallbackSources = []) => {\r\n  console.error('Streaming error:', error);\r\n\r\n  if (fallbackSources.length > 0) {\r\n    return {\r\n      success: false,\r\n      error: error.message,\r\n      fallback: fallbackSources[0],\r\n      hasFallback: true\r\n    };\r\n  }\r\n\r\n  return {\r\n    success: false,\r\n    error: error.message,\r\n    hasFallback: false\r\n  };\r\n};\r\n\r\nexport default vidsrcApi;\r\n\r\n// Test function to verify video streaming functionality\r\nexport const testVideoStreaming = async () => {\r\n  console.log('🧪 Testing Video Streaming Functionality...');\r\n\r\n  // Test data - specific movies mentioned by user\r\n  const testMovies = [\r\n    { id: '278', name: 'Shawshank Redemption' },\r\n    { id: '155', name: 'The Dark Knight' },\r\n    { id: '550', name: 'Fight Club' }\r\n  ];\r\n  const testTVId = '1399'; // Game of Thrones\r\n\r\n  try {\r\n    // Test 1: Get movie sources for each test movie\r\n    console.log('\\n📽️ Testing Movie Sources...');\r\n    for (const movie of testMovies) {\r\n      const movieSources = vidsrcApi.getMovieSources(movie.id, { includeAlternatives: true });\r\n      console.log(`Found ${movieSources.length} sources for ${movie.name} (${movie.id})`);\r\n    }\r\n\r\n    // Test 2: Get TV sources\r\n    console.log('\\n📺 Testing TV Sources...');\r\n    const tvSources = vidsrcApi.getTVSources(testTVId, 1, 1, { includeAlternatives: true });\r\n    console.log(`Found ${tvSources.length} TV sources`);\r\n\r\n    // Test 3: Test specific movies for availability\r\n    console.log('\\n🔍 Testing Specific Movie Availability...');\r\n    for (const movie of testMovies) {\r\n      console.log(`\\n--- Testing ${movie.name} (${movie.id}) ---`);\r\n\r\n      // Test the primary source\r\n      const primaryStream = vidsrcApi.getMovieStream(movie.id, { quality: '1080p' });\r\n      console.log(`Primary URL: ${primaryStream.url}`);\r\n\r\n      try {\r\n        const result = await vidsrcApi.testStream(primaryStream.url, 5000);\r\n        console.log(`✅ Primary: ${result.available ? 'Available' : 'Failed'} (${result.loadTime}ms)`);\r\n\r\n        if (result.available) {\r\n          console.log(`🎉 SUCCESS: ${movie.name} is working!`);\r\n        } else {\r\n          console.log(`❌ Primary failed, trying alternatives...`);\r\n\r\n          // Try alternative sources\r\n          const altUrls = vidsrcApi.tryAlternativeUrls(movie.id, 'movie');\r\n          console.log(`Found ${altUrls.length} alternative URLs`);\r\n\r\n          for (let i = 0; i < Math.min(3, altUrls.length); i++) {\r\n            try {\r\n              const altResult = await vidsrcApi.testStream(altUrls[i], 3000);\r\n              console.log(`  Alt ${i + 1}: ${altResult.available ? 'Available' : 'Failed'} (${altResult.loadTime}ms)`);\r\n              if (altResult.available) {\r\n                console.log(`  🎉 Alternative ${i + 1} works!`);\r\n                break;\r\n              }\r\n            } catch (altError) {\r\n              console.log(`  Alt ${i + 1}: Error - ${altError.message}`);\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.log(`❌ Error testing ${movie.name}: ${error.message}`);\r\n      }\r\n    }\r\n\r\n    // Test 4: Test fallback system\r\n    console.log('\\n🔄 Testing Fallback System...');\r\n    const fallbackStatus = vidsrcApi.getFallbackStatus();\r\n    console.log('Fallback Status:', fallbackStatus);\r\n\r\n    console.log('\\n✅ Video streaming test completed!');\r\n    return {\r\n      success: true,\r\n      testedMovies: testMovies.length,\r\n      tvSources: tvSources.length\r\n    };\r\n\r\n  } catch (error) {\r\n    console.error('❌ Video streaming test failed:', error);\r\n    return {\r\n      success: false,\r\n      error: error.message\r\n    };\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}